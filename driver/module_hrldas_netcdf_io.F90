module module_hrldas_netcdf_io
  use module_date_utilities
  use netcdf
#ifdef MPP_LAND
  use mpi
  use module_mpp_land
#endif
  implicit none
  private
  public :: hrldas_diminfo
  public :: hrldas_hdrinfo
  public :: hrldas_const_read
  public :: hrldas_init_read
  public :: hrldas_input_t
  public :: hrldas_input_read
  public :: hrldas_output_prepare
  public :: hrldas_output_definemode
  public :: hrldas_output_add
  public :: hrldas_output_finalize
  public :: hrldas_restart_read
  public :: hrldas_restart_prepare
  public :: hrldas_restart_get
  public :: hrldas_restart_add
  public :: hrldas_restart_finalize

  public :: read_mmf_runoff
  public :: hrldas_parm_veg_read

  logical, parameter :: FATAL = .TRUE.
  logical, parameter :: NOT_FATAL = .FALSE.

  type hrldas_input_t
     character(len=19) :: read_date
     real, pointer, dimension(:,:) :: t
     real, pointer, dimension(:,:) :: q
     real, pointer, dimension(:,:) :: u
     real, pointer, dimension(:,:) :: v
     real, pointer, dimension(:,:) :: p
     real, pointer, dimension(:,:) :: lw
     real, pointer, dimension(:,:) :: sw
     real, pointer, dimension(:,:) :: pcp
     real, pointer, dimension(:,:) :: fpar
     real, pointer, dimension(:,:) :: lai
  end type hrldas_input_t

  character(len=256), private :: restart_filename_remember
  integer, private :: iswater_remember
  integer, private :: xstartpar_remember
  integer, private, allocatable, dimension(:,:) :: vegtyp_remember
  integer, private :: ncid_remember
  integer, private :: output_count_remember = 0
  logical, private :: define_mode_remember
  integer, private :: dimid_ix_remember
  integer, private :: dimid_jx_remember
  integer, private :: dimid_times_remember
  integer, private :: dimid_layers_remember
  integer, private :: dimid_snow_layers_remember

  interface hrldas_output_prepare
#ifdef MPP_LAND
     module procedure hrldas_output_prepare_mpp
#else
     module procedure hrldas_output_prepare_seq
#endif
  end interface hrldas_output_prepare

  interface hrldas_restart_prepare
#ifdef MPP_LAND
     module procedure hrldas_restart_prepare_mpp
#else
     module procedure hrldas_restart_prepare_seq
#endif
  end interface hrldas_restart_prepare

  interface hrldas_restart_add
#ifdef MPP_LAND
     module procedure hrldas_restart_add_real2d_mpp
     module procedure hrldas_restart_add_integer2d_mpp
     module procedure hrldas_restart_add_3d_mpp
#else
     module procedure hrldas_restart_add_real2d
     module procedure hrldas_restart_add_integer2d
     module procedure hrldas_restart_add_3d
#endif
  end interface hrldas_restart_add

  interface hrldas_restart_get
#ifdef MPP_LAND
     module procedure hrldas_restart_get_real2d_mpp
     module procedure hrldas_restart_get_integer2d_mpp
     module procedure hrldas_restart_get_3d_mpp
     module procedure hrldas_restart_get_att
#else
     module procedure hrldas_restart_get_real2d
     module procedure hrldas_restart_get_integer2d
     module procedure hrldas_restart_get_3d
     module procedure hrldas_restart_get_att
#endif
  end interface hrldas_restart_get

  interface hrldas_output_add
#ifdef MPP_LAND
     module procedure hrldas_output_add_real2d_mpp
     module procedure hrldas_output_add_integer2d_mpp
     module procedure hrldas_output_add_3d_mpp
#else
     module procedure hrldas_output_add_real2d
     module procedure hrldas_output_add_integer2d
     module procedure hrldas_output_add_3d
#endif
  end interface hrldas_output_add

  interface hrldas_init_read
#ifdef MPP_LAND
     module procedure hrldas_init_read_mpp
#else
     module procedure hrldas_init_read_seq
#endif
  end interface hrldas_init_read

  interface netcdf_get
#ifdef MPP_LAND
     module procedure netcdf_get_real3d_mpp
     module procedure netcdf_get_real2d_mpp
     module procedure netcdf_get_integer2d_mpp
#else
     module procedure netcdf_get_real3d_seq
     module procedure netcdf_get_real2d_seq
     module procedure netcdf_get_integer2d_seq
#endif
  end interface netcdf_get

contains

  integer function checkRstV(name)
    implicit none
    character(len=*) name
    integer :: ncid, ierr, varid
#ifdef MPP_LAND
    if(my_id .eq. io_id) then
#endif
       checkRstV = nf90_open(trim(restart_filename_remember), NF90_NOWRITE, ncid)
       if(checkRstV .eq. 0) then
          checkRstV = nf90_inq_varid(ncid, name, varid)
       endif
#ifdef MPP_LAND
    endif
    call mpp_land_bcast(checkRstV, 1, io_id)
#endif
  end function checkRstV


  subroutine hrldas_diminfo(filename, ix, jx)
    implicit none
    character(len=*), intent(in) :: filename
    integer, intent(out) :: ix, jx ! dimensions
    integer :: ncid, dimid, ierr

    ierr = nf90_open(filename, NF90_NOWRITE, ncid)
    call error_handler(ierr, failure="ERROR[HRLDAS_DIMINFO]: Problems opening file " // trim(filename))

    ierr = nf90_inq_dimid(ncid, "west_east", dimid)
    call error_handler(ierr, failure="ERROR[HRLDAS_DIMINFO]: Problems finding dimension 'west_east'")

    ierr = nf90_inquire_dimension(ncid, dimid, len=ix)
    call error_handler(ierr, failure="ERROR[HRLDAS_DIMINFO]: Problems finding dimension length for 'west_east'")

    ierr = nf90_inq_dimid(ncid, "south_north", dimid)
    call error_handler(ierr, failure="ERROR[HRLDAS_DIMINFO]: Problems finding dimension 'south_north'")

    ierr = nf90_inquire_dimension(ncid, dimid, len=jx)
    call error_handler(ierr, failure="ERROR[HRLDAS_DIMINFO]: Problems finding dimension length for 'south_north'")

    ierr = nf90_close(ncid)
    call error_handler(ierr, failure="ERROR[HRLDAS_DIMINFO]: Problems closing NetCDF file.")
  end subroutine hrldas_diminfo


  subroutine hrldas_hdrinfo(filename, &
       xstart, xend, ystart, yend, &
       llanduse, iswater, isurban, isice, isoilwater, &
       dx, dy, truelat1, truelat2, cen_lon, mapproj)
    ! Return the dimensions of the grid and some map information.
    implicit none
    character(len=*), intent(in) :: filename
    integer,          intent(in) :: xstart, xend ! Subwindow definition
    integer,          intent(in) :: ystart, yend ! Subwindow definition
    integer,          intent(out) :: mapproj
    character(len=*), intent(out) :: llanduse  ! Landuse dataset (USGS or MODI)
    integer,          intent(out) :: iswater   ! vegetation category corresponding to water bodies
    integer,          intent(out) :: isurban   ! vegetation category corresponding to urban areas
    integer,          intent(out) :: isice     ! vegetation category corresponding to ice areas
    integer, intent(out) :: isoilwater ! soil category corresponding to water bodies
    real,             intent(out) :: dx
    real,             intent(out) :: dy
    real,             intent(out) :: truelat1
    real,             intent(out) :: truelat2
    real,             intent(out) :: cen_lon
    integer :: ncid, dimid, varid, ierr
    character(len=256) :: units
    integer :: i

    ! Open the NetCDF file.
    print *, 'INFO[HRLDAS_HDRINFO]: reading file ' // trim(filename)

    ierr = nf90_open(filename, NF90_NOWRITE, ncid)
    call error_handler(ierr, failure="ERROR[HRLDAS_HDRINFO]: Problem opening file "//trim(filename))

    ierr = nf90_get_att(ncid, NF90_GLOBAL, "DX", dx)
    call error_handler(ierr, failure="ERROR[HRLDAS_HDRINFO]: Problems finding global attribute 'DX'")

    ierr = nf90_get_att(ncid, NF90_GLOBAL, "DY", dy)
    call error_handler(ierr, failure="ERROR[HRLDAS_HDRINFO]: Problems finding global attribute 'DY'")

    ierr = nf90_get_att(ncid, NF90_GLOBAL, "TRUELAT1", truelat1)
    call error_handler(ierr, failure="ERROR[HRLDAS_HDRINFO]: Problems finding global attribute 'TRUELAT1'")

    ierr = nf90_get_att(ncid, NF90_GLOBAL, "TRUELAT2", truelat2)
    call error_handler(ierr, failure="ERROR[HRLDAS_HDRINFO]: Problems finding global attribute 'TRUELAT2'")

    ierr = nf90_get_att(ncid, NF90_GLOBAL, "STAND_LON", cen_lon)
    call error_handler(ierr, failure="ERROR[HRLDAS_HDRINFO]: Problems finding global attribute 'STAND_LON'")

    ierr = nf90_get_att(ncid, NF90_GLOBAL, "MAP_PROJ", mapproj)
    call error_handler(ierr, failure="ERROR[HRLDAS_HDRINFO]: Problems finding global attribute 'MAP_PROJ'")

    ierr = nf90_get_att(ncid, NF90_GLOBAL, "ISWATER", iswater)
    call error_handler(ierr, failure="ERROR[HRLDAS_HDRINFO]: Problems finding global attribute 'ISWATER'")

    ierr = nf90_get_att(ncid, NF90_GLOBAL, "ISURBAN", isurban)
    call error_handler(ierr, failure="ERROR[HRLDAS_HDRINFO]: Problems finding global attribute 'ISURBAN'")

    ierr = nf90_get_att(ncid, NF90_GLOBAL, "ISICE", isice)
    call error_handler(ierr, failure="ERROR[HRLDAS_HDRINFO]: Problems finding global attribute 'ISICE'")

    ierr = nf90_get_att(ncid, NF90_GLOBAL, "ISOILWATER", isoilwater)
    call error_handler(ierr, failure="ERROR[HRLDAS_HDRINFO]: Problems finding global attribute 'ISOILWATER'")

    ierr = nf90_get_att(ncid, NF90_GLOBAL, "MMINLU", llanduse)
    call error_handler(ierr, failure="ERROR[HRLDAS_HDRINFO]: Problems finding global attribute 'MMINLU'")

    ! IBM XLF seems to need something like this:
    do i = 1, 256
       if (ichar(llanduse(i:i)) == 0) llanduse(i:i) = " "
    enddo

    ierr = nf90_close(ncid)
    call error_handler(ierr, failure="ERROR[HRLDAS_HDRINFO]: Problems closing NetCDF file.")
  end subroutine hrldas_hdrinfo


  subroutine hrldas_const_read(filename, &
       xstart, xend, ystart, yend, &
       iswater, &
       latitude, longitude, &
       xland, vegtyp, soltyp, terrain, tbot_2d, seaice, msftx, msfty)
    implicit none
    character(len=*), intent(in) :: filename
    integer, intent(in) :: xstart, xend, ystart, yend
    integer, intent(in) :: iswater
    real, dimension(xstart:xend,ystart:yend), intent(out) :: latitude
    real, dimension(xstart:xend,ystart:yend), intent(out) :: longitude
    real, dimension(xstart:xend,ystart:yend), intent(out) :: xland
    integer, dimension(xstart:xend,ystart:yend), intent(out) :: vegtyp
    integer, dimension(xstart:xend,ystart:yend), intent(out) :: soltyp
    real, dimension(xstart:xend,ystart:yend), intent(out) :: terrain
    real, dimension(xstart:xend,ystart:yend), intent(out) :: tbot_2d
    real, dimension(xstart:xend,ystart:yend), intent(out) :: seaice
    real, dimension(xstart:xend,ystart:yend), intent(out) :: msftx
    real, dimension(xstart:xend,ystart:yend), intent(out) :: msfty

    character(len=256) :: units
    integer :: ierr
    integer :: ncid
    real, dimension(xstart:xend,ystart:yend) :: xdum

    ! Open the NetCDF file.
    write(*,*) 'INFO[HRLDAS_CONST_READ]: reading file ' // trim(filename)
    ierr = nf90_open(filename, NF90_NOWRITE, ncid)
    call error_handler(ierr, failure="ERROR[HRLDAS_CONST_READ]: Problems opening file "//trim(filename))

    ! Get Latitude (lat)
    call netcdf_get(ncid, "XLAT", latitude, units, xstart, xend, ystart, yend, FATAL, ierr)

    ! Get Longitude (lon)
    call netcdf_get(ncid, "XLONG", longitude, units, xstart, xend, ystart, yend, FATAL, ierr)

    ! Get land mask (xland)
    call netcdf_get(ncid, "XLAND", xland, units, xstart, xend, ystart, yend, NOT_FATAL, ierr)

    ! Get seaice (seaice)
    call netcdf_get(ncid, "SEAICE", seaice, units, xstart, xend, ystart, yend, NOT_FATAL, ierr)

    ! Get Terrain (avg)
    call netcdf_get(ncid, "HGT", terrain, units, xstart, xend, ystart, yend, FATAL, ierr)

    ! Get Deep layer temperature (TMN)
    call netcdf_get(ncid, "TMN", tbot_2d, units, xstart, xend, ystart, yend, FATAL, ierr)

    ! Get Map Factors (MAPFAC_MX)
    call netcdf_get(ncid, "MAPFAC_MX", msftx, units, xstart, xend, ystart, yend, NOT_FATAL, ierr)
    if (ierr /= 0) write(*,*) 'WARNING[HRLDAS_CONST_READ]: Did not find MAPFAC_MX, only needed for iopt_run=5'

    ! Get Map Factors (MAPFAC_MY)
    call netcdf_get(ncid, "MAPFAC_MY", msfty, units, xstart, xend, ystart, yend, NOT_FATAL, ierr)
    if (ierr /= 0) write(*,*) 'WARNING[HRLDAS_CONST_READ]: Did not find MAPFAC_MY, only needed for iopt_run=5'

    ! Get Dominant Land Use categories (use)
    call netcdf_get(ncid, 'IVGTYP', vegtyp, units, xstart, xend, ystart, yend, FATAL, ierr)

    ! Get Dominant Soil Type categories in the top layer (stl)
    call netcdf_get(ncid, 'ISLTYP', soltyp, units, xstart, xend, ystart, yend, FATAL, ierr)

    ! Close the NetCDF file
    ierr = nf90_close(ncid)
    call error_handler(ierr, failure="ERROR[HRLDAS_CONST_READ]: Problems closing file "//trim(filename))

    ! Make sure vegtyp and soltyp are consistent when it comes to water points,
    ! by setting soil category to water when vegetation category is water, and
    ! vice-versa.
    where (vegtyp == ISWATER) soltyp = 14
    where (soltyp == 14) vegtyp = ISWATER
  end subroutine hrldas_const_read


  subroutine read_mmf_runoff(wrfinput_flnm, &
       xstart, xend, ystart, yend, &
       zwt,eqzwt,riverbed,rivercond,pexp,fdepth)
    implicit none
    character(len=*),          intent(in)  :: wrfinput_flnm
    integer,                   intent(in)  :: xstart, xend, ystart, yend
    real,    dimension(xstart:xend,ystart:yend), intent(out) :: zwt
    real,    dimension(xstart:xend,ystart:yend), intent(out) :: eqzwt
    real,    dimension(xstart:xend,ystart:yend), intent(out) :: riverbed
    real,    dimension(xstart:xend,ystart:yend), intent(out) :: rivercond
    real,    dimension(xstart:xend,ystart:yend), intent(out) :: pexp
    real,    dimension(xstart:xend,ystart:yend), intent(out) :: fdepth

    character(len=256) :: units
    integer :: ierr
    integer :: ncid
    real, dimension(xstart:xend,ystart:yend) :: xdum
    integer :: rank

#ifdef _PARALLEL_
    call MPI_COMM_RANK(MPI_COMM_WORLD, rank, ierr)
    if (ierr /= MPI_SUCCESS) stop "MPI_COMM_RANK"
#else
    rank = 0
#endif

    ! Open the NetCDF file.
    if (rank == 0) write(*,'("wrfinput_flnm: ''", A, "''")') trim(wrfinput_flnm)
#ifdef _PARALLEL_
    ierr = nf90_open_par(wrfinput_flnm, NF90_NOWRITE, MPI_COMM_WORLD, MPI_INFO_NULL, ncid)
#else
    ierr = nf90_open(wrfinput_flnm, NF90_NOWRITE, ncid)
#endif
    if (ierr /= 0) then
       write(*,'("read_mmf_runoff:  Problem opening wrfinput file: ''", A, "''")') trim(wrfinput_flnm)
#ifdef _PARALLEL_
       call mpi_finalize(ierr)
       if (ierr /= 0) write(*, '("Problem with MPI_finalize.")')
#endif
       stop
    endif

    ! Get water table depth (ZWT)
    call netcdf_get(ncid, "ZWT", zwt, units, xstart, xend, ystart, yend, FATAL, ierr)

    ! Get equilibrium water table depth (EQZWT)
    call netcdf_get(ncid, "EQZWT", eqzwt, units, xstart, xend, ystart, yend, FATAL, ierr)

    ! Get equilibrium water table depth (RIVERBED)
    call netcdf_get(ncid, "RIVERBED", riverbed, units, xstart, xend, ystart, yend, FATAL, ierr)

    ! Get equilibrium water table depth (RIVERCOND)
    call netcdf_get(ncid, "RIVERCOND", rivercond, units, xstart, xend, ystart, yend, FATAL, ierr)

    ! Get equilibrium water table depth (PEXP)
    call netcdf_get(ncid, "PEXP", pexp, units, xstart, xend, ystart, yend, FATAL, ierr)

    ! Get equilibrium water table depth (FDEPTH)
    call netcdf_get(ncid, "FDEPTH", fdepth, units, xstart, xend, ystart, yend, FATAL, ierr)

    ! Close the NetCDF file
    ierr = nf90_close(ncid)
    if (ierr /= 0) stop "MODULE_NOAHLSM_HRLDAS_INPUT:  READLAND_HRLDAS:  NF90_CLOSE"

  end subroutine read_mmf_runoff


#ifdef MPP_LAND
  subroutine netcdf_get_real3d_mpp(ncid, name, array, units, xstart, xend, ystart, yend, &
       fatal_if_error, ierr)
    implicit none
    integer, intent(in) :: ncid
    character(len=*), intent(in) :: name
    integer, intent(in) :: xstart, xend, ystart, yend
    real, dimension(:,:,:), intent(out) :: array
    character(len=*), intent(out) :: units
    logical, intent(in) :: fatal_if_error
    integer, intent(out) :: ierr
    real, allocatable :: garray(:,:,:)

    if (my_id == io_id) then
       allocate(garray(1:global_nx,size(array,2),1:global_ny))
       call netcdf_get_real3d_seq(ncid, name, garray, units, 1, global_nx, 1, global_ny, &
            fatal_if_error, ierr)
    endif

    call mpp_land_bcast(ierr, 1, io_id)
    call mpp_land_bcast(units, len(units), io_id)
    call decompose_data_real3d(garray, array, size(array,2))

    if (my_id == io_id) then
       deallocate(garray)
    endif
  end subroutine netcdf_get_real3d_mpp


  subroutine netcdf_get_real2d_mpp(ncid, name, array, units, xstart, xend, ystart, yend, &
       fatal_if_error, ierr)
    implicit none
    integer, intent(in) :: ncid
    character(len=*), intent(in) :: name
    integer, intent(in) :: xstart, xend, ystart, yend
    real, dimension(xstart:xend,ystart:yend), intent(out) :: array
    character(len=*), intent(out) :: units
    logical, intent(in) :: fatal_if_error
    integer, intent(out) :: ierr
    real, allocatable :: garray(:,:)

    if (my_id == io_id) then
       allocate(garray(1:global_nx,1:global_ny))
       call netcdf_get_real2d_seq(ncid, name, garray, units, 1, global_nx, 1, global_ny, &
            fatal_if_error, ierr)
    endif

    call mpp_land_bcast(ierr, 1, io_id)
    call mpp_land_bcast(units, len(units), io_id)
    call decompose_data_real(garray, array)

    if (my_id == io_id) then
       deallocate(garray)
    endif
  end subroutine netcdf_get_real2d_mpp


  subroutine netcdf_get_integer2d_mpp(ncid, name, array, units, xstart, xend, ystart, yend, &
       fatal_if_error, ierr)
    implicit none
    integer, intent(in) :: ncid
    character(len=*), intent(in) :: name
    integer, intent(in) :: xstart, xend, ystart, yend
    integer, dimension(xstart:xend,ystart:yend), intent(out) :: array
    character(len=*), intent(out) :: units
    logical, intent(in) :: fatal_if_error
    integer, intent(out) :: ierr
    integer, allocatable :: garray(:,:)

    if (my_id == io_id) then
       allocate(garray(1:global_nx,1:global_ny))
       call netcdf_get_integer2d_seq(ncid, name, garray, units, 1, global_nx, 1, global_ny, &
            fatal_if_error, ierr)
    endif

    call mpp_land_bcast(ierr, 1, io_id)
    call mpp_land_bcast(units, len(units), io_id)
    call decompose_data_int(garray, array)

    if (my_id == io_id) then
       deallocate(garray)
    endif
  end subroutine netcdf_get_integer2d_mpp
#endif


  subroutine netcdf_get_real3d_seq(ncid, name, array, units, xstart, xend, ystart, yend, &
       fatal_if_error, ierr)
    implicit none
    integer, intent(in) :: ncid
    character(len=*), intent(in) :: name
    integer, intent(in) :: xstart, xend, ystart, yend
    real, dimension(:,:,:), intent(out) :: array
    character(len=*), intent(out) :: units
    logical, intent(in) :: fatal_if_error
    integer, intent(out) :: ierr
    integer :: varid

    ierr = nf90_inq_varid(ncid, name, varid)
    if (ierr /= NF90_NOERR) then
       if (fatal_if_error) then
          write(*,*) 'ERROR[NETCDF_GET]: Problem finding variable '//trim(name)
          stop
       else
          units = 'not available'
          return
       endif
    endif

    ierr = nf90_get_att(ncid, varid, "units", units)
    if (ierr /= NF90_NOERR) then
      units = 'unknown'
      ierr = NF90_NOERR
    endif

    ierr = nf90_get_var(ncid, varid, array, start=(/xstart,1,ystart/), count=(/xend-xstart+1,size(array,2),yend-ystart+1/))
    if (ierr /= NF90_NOERR) then
       if (fatal_if_error) then
          write(*,*) 'ERROR[NETCDF_GET]: Problem reading variable '//trim(name)
          stop
       else
          return
       endif
    endif
  end subroutine netcdf_get_real3d_seq


  subroutine netcdf_get_real2d_seq(ncid, name, array, units, xstart, xend, ystart, yend, &
       fatal_if_error, ierr)
    implicit none
    integer, intent(in) :: ncid
    character(len=*), intent(in) :: name
    integer, intent(in) :: xstart, xend, ystart, yend
    real, dimension(xstart:xend,ystart:yend), intent(out) :: array
    character(len=*), intent(out) :: units
    logical, intent(in) :: fatal_if_error
    integer, intent(out) :: ierr
    integer :: varid

    ierr = nf90_inq_varid(ncid, name, varid)
    if (ierr /= NF90_NOERR) then
       if (fatal_if_error) then
          write(*,*) 'ERROR[NETCDF_GET]: Problem finding variable '//trim(name)
          stop
       else
          units = 'not available'
          return
       endif
    endif

    ierr = nf90_get_att(ncid, varid, "units", units)
    if (ierr /= NF90_NOERR) then
      units = 'unknown'
      ierr = NF90_NOERR
    endif

    ierr = nf90_get_var(ncid, varid, array, start=(/xstart,ystart/), count=(/xend-xstart+1,yend-ystart+1/))
    if (ierr /= NF90_NOERR) then
       if (fatal_if_error) then
          ierr = ierr
          write(*,*) 'ERROR[NETCDF_GET]: Problem reading variable '//trim(name)
          stop
       else
          ierr = ierr
          return
       endif
    endif
  end subroutine netcdf_get_real2d_seq


  subroutine netcdf_get_integer2d_seq(ncid, name, array, units, xstart, xend, ystart, yend, &
       fatal_if_error, ierr)
    implicit none
    integer, intent(in) :: ncid
    character(len=*), intent(in) :: name
    integer, intent(in) :: xstart, xend, ystart, yend
    integer, dimension(xstart:xend,ystart:yend), intent(out) :: array
    character(len=*), intent(out) :: units
    logical, intent(in) :: fatal_if_error
    integer, intent(out) :: ierr
    integer :: varid

    ierr = nf90_inq_varid(ncid, name, varid)
    if (ierr /= NF90_NOERR) then
       if (fatal_if_error) then
          write(*,*) 'ERROR[NETCDF_GET]: Problem finding variable '//trim(name)
          stop
       else
          return
       endif
    endif

    ierr = nf90_get_att(ncid, varid, "units", units)
    if (ierr /= NF90_NOERR) then
      units = 'unknown'
      ierr = NF90_NOERR
    endif

    ierr = nf90_get_var(ncid, varid, array, start=(/xstart,ystart/), count=(/xend-xstart+1,yend-ystart+1/))
    if (ierr /= NF90_NOERR) then
       if (fatal_if_error) then
          write(*,*) 'ERROR[NETCDF_GET]: Problem reading variable '//trim(name)
          stop
       else
          return
       endif
    endif
  end subroutine netcdf_get_integer2d_seq


  subroutine get_2d_netcdf_soillevel(ncid, name, array, units, xstart, xend, ystart, yend, &
       fatal_if_error, layer_bottom, layer_top, ierr)
    implicit none
    integer, intent(in) :: ncid
    character(len=*), intent(in) :: name
    integer, intent(in) :: xstart, xend, ystart, yend
    real, dimension(xstart:xend,ystart:yend), intent(out) :: array
    character(len=256), intent(out) :: units
    ! FATAL_IF_ERROR:  an input code value:
    !      .TRUE. if an error in reading the data should stop the program.
    !      Otherwise the, IERR error flag is set, but the program continues.
    logical, intent(in) :: fatal_if_error
    integer, intent(out) :: ierr
    real, intent(out) :: layer_bottom
    real, intent(out) :: layer_top

    integer :: iret, varid
#ifdef MPP_LAND
    real:: g_array(global_nx,global_ny)
#endif

    units = " "

#ifdef MPP_LAND
    if(my_id .eq. 0) then
#endif

       iret = nf90_inq_varid(ncid,  name,  varid)
       if (iret /= 0) then
          if (FATAL_IF_ERROR) then
             print*, 'name = "', trim(name)//'"'
             stop "MODULE_NOAHLSM_HRLDAS_INPUT:  get_2d_netcdf:  nf90_inq_varid"
          else
             ierr = iret
#ifdef MPP_LAND
             goto 9992
#endif
             return
          endif
       endif

       iret = nf90_get_att(ncid, varid, "units", units)
       if (iret /= 0) units = "units unknown"

#ifdef MPP_LAND
       iret = nf90_get_var(ncid, varid, values=g_array, start=(/1,1/), count=(/global_nx,global_ny/))
#else
       iret = nf90_get_var(ncid, varid, values=array, start=(/xstart,ystart/), count=(/xend-xstart+1,yend-ystart+1/))
#endif
       if (iret /= 0) then
          if (FATAL_IF_ERROR) then
             print*, 'name = "', trim(name)//'"'
             print*, 'varid =', varid
             print*, trim(nf90_strerror(iret))
             stop "MODULE_NOAHLSM_HRLDAS_INPUT:  get_2d_netcdf:  nf90_get_var"
          else
             ierr = iret
#ifdef MPP_LAND
             goto 9992
#endif
             return
          endif
       endif

       ! Also get some metadata about the soil layers:
       iret = nf90_get_att(ncid, varid, "layer_top", layer_top)
       call error_handler(iret, "Attempted to find 'layer_top' attribute on variable "//trim(name))

       iret = nf90_get_att(ncid, varid, "layer_bottom", layer_bottom)
       call error_handler(iret, "Attempted to find 'layer_bottom' attribute on variable "//trim(name))

       ierr = 0;
#ifdef MPP_LAND
9992   continue
    endif
    call mpp_land_bcast(ierr, 1, io_id)
    call mpp_land_bcast(units, 256, io_id)
    call mpp_land_bcast(layer_bottom, 1, io_id)
    call mpp_land_bcast(layer_top, 1, io_id)
    if(ierr /= 0) return
    call decompose_data_real(g_array,array)
#endif
  end subroutine get_2d_netcdf_soillevel

#ifdef MPP_LAND
  subroutine hrldas_init_read_mpp(filename, xstart, xend, ystart, yend, nsoil, &
       smc, stc, cmc, t1, weasd, snodep, fndsnowh)
    implicit none
    character(len=*), intent(in) :: filename
    integer, intent(in) :: xstart, xend
    integer, intent(in) :: ystart, yend
    integer, intent(in) :: nsoil
    real, dimension(xstart:xend,nsoil,ystart:yend), intent(out) :: smc
    real, dimension(xstart:xend,nsoil,ystart:yend), intent(out) :: stc
    real, dimension(xstart:xend,ystart:yend), intent(out) :: cmc
    real, dimension(xstart:xend,ystart:yend), intent(out) :: t1
    real, dimension(xstart:xend,ystart:yend), intent(out) :: weasd
    real, dimension(xstart:xend,ystart:yend), intent(out) :: snodep
    logical, intent(out) :: fndsnowh

    real, allocatable :: gsmc(:,:,:)
    real, allocatable :: gstc(:,:,:)
    real, allocatable :: gcmc(:,:)
    real, allocatable :: gt1(:,:)
    real, allocatable :: gweasd(:,:)
    real, allocatable :: gsnodep(:,:)

    if (my_id == io_id) then
       allocate(gsmc(global_nx,nsoil,global_ny))
       allocate(gstc(global_nx,nsoil,global_ny))
       allocate(gcmc(global_nx,global_ny))
       allocate(gt1(global_nx,global_ny))
       allocate(gweasd(global_nx,global_ny))
       allocate(gsnodep(global_nx,global_ny))
       call hrldas_init_read_seq(filename, 1, global_nx, 1, global_ny, nsoil, &
            gsmc, gstc, gcmc, gt1, gweasd, gsnodep, fndsnowh)
    endif
    call decompose_data_real3d(gsmc, smc, nsoil)
    call decompose_data_real3d(gstc, stc, nsoil)
    call decompose_data_real(gcmc, cmc)
    call decompose_data_real(gt1, t1)
    call decompose_data_real(gweasd, weasd)
    call decompose_data_real(gsnodep, snodep)
    call mpp_land_bcast(fndsnowh, 1, io_id)
    if (my_id == io_id) then
       deallocate(gsmc)
       deallocate(gstc)
       deallocate(gcmc)
       deallocate(gt1)
       deallocate(gweasd)
       deallocate(gsnodep)
    endif
  end subroutine hrldas_init_read_mpp
#endif

  subroutine hrldas_init_read_seq(filename, xstart, xend, ystart, yend, nsoil, &
       smc, stc, cmc, t1, weasd, snodep, fndsnowh)
    implicit none
    character(len=*), intent(in) :: filename
    integer, intent(in) :: xstart, xend
    integer, intent(in) :: ystart, yend
    integer, intent(in) :: nsoil
    real, dimension(xstart:xend,nsoil,ystart:yend), intent(out) :: smc
    real, dimension(xstart:xend,nsoil,ystart:yend), intent(out) :: stc
    real, dimension(xstart:xend,ystart:yend), intent(out) :: cmc
    real, dimension(xstart:xend,ystart:yend), intent(out) :: t1
    real, dimension(xstart:xend,ystart:yend), intent(out) :: weasd
    real, dimension(xstart:xend,ystart:yend), intent(out) :: snodep
    logical, intent(out) :: fndsnowh

    character(len=256) :: units
    character(len=8) :: name
    integer :: ncid, ierr

    ierr = nf90_open(filename, NF90_NOWRITE, ncid)
    if (ierr /= NF90_NOERR) then
       write(*,*) 'ERROR[HRLDAS_INIT_READ]: Problem opening netcdf file ' // trim(filename)
       stop
    end if

    call netcdf_get(ncid, "CANWAT", cmc, units, xstart, xend, ystart, yend, FATAL, ierr)
    call netcdf_get(ncid, "SKINTEMP", t1, units, xstart, xend, ystart, yend, FATAL, ierr)
    call netcdf_get(ncid, "WEASD", weasd, units, xstart, xend, ystart, yend, FATAL, ierr)
    if (trim(units) == "m") then
       ! No conversion necessary
    else if (trim(units) == "mm") then
       ! convert WEASD from mm to m
       weasd = weasd * 1.E-3
    else if (trim(units) == "kg m{-2}" .or. trim(units) == 'kg m-2') then
       ! convert WEASD from mm to m
       weasd = weasd * 1.E-3
    else if (trim(units) == "kg/m2") then
       ! convert WEASD from mm to m
       weasd = weasd * 1.E-3
    else
       write(*,*) 'ERROR[HRLDAS_INIT_READ]: unknown WEASD units: ' // units
       write(*,*) 'INFO[HRLDAS_INIT_READ]: recognizable units are: m, mm, kg m{-2}, kg m-2, kg/m2'
       stop
    endif

    call netcdf_get(ncid, "SNODEP", snodep, units, xstart, xend, ystart, yend, NOT_FATAL, ierr)
    if (ierr == 0) then
       fndsnowh = .true.
    else
       fndsnowh = .false.
       snodep(:,:) = 0.0
    endif

    call netcdf_get(ncid, 'STEMP', stc, units, xstart, xend, ystart, yend, FATAL, ierr)
    if (ierr /= NF90_NOERR) then
       write(*,*) 'ERROR[HRLDAS_INIT_READ]: Problem reading STEMP'
       stop
    endif

    call netcdf_get(ncid, 'SMOIS', smc, units, xstart, xend, ystart, yend, FATAL, ierr)
    if (ierr /= NF90_NOERR) then
       write(*,*) 'ERROR[HRLDAS_INIT_READ]: Problem reading SMOIS'
       stop
    endif

    ierr = nf90_close(ncid)
    if (ierr /= NF90_NOERR) then
       write(*,*) 'ERROR[HRLDAS_INIT_READ]: Problem closing file ' // trim(filename)
       stop
    endif
  end subroutine hrldas_init_read_seq


  subroutine hrldas_init_read_old(filename, xstart, xend, ystart, yend, nsoil, sldpth, target_date, &
       ldasin_version, smc, stc, cmc, t1, weasd, snodep, fndsnowh)
    implicit none
    character(len=*), intent(in) :: filename
    integer, intent(in) :: xstart, xend
    integer, intent(in) :: ystart, yend
    integer, intent(in) :: nsoil
    real, dimension(nsoil), intent(in) :: sldpth
    character(len=*), intent(in) :: target_date

    integer, intent(out) :: ldasin_version
    real, dimension(xstart:xend,nsoil,ystart:yend), intent(out) :: smc
    real, dimension(xstart:xend,nsoil,ystart:yend), intent(out) :: stc
    real, dimension(xstart:xend,ystart:yend), intent(out) :: cmc
    real, dimension(xstart:xend,ystart:yend), intent(out) :: t1
    real, dimension(xstart:xend,ystart:yend), intent(out) :: weasd
    real, dimension(xstart:xend,ystart:yend), intent(out) :: snodep
    logical, intent(out) :: fndsnowh

    character(len=256) :: titlestr
    character(len=256) :: units
    character(len=8)   :: name
    character(len=256) :: ldasin_llanduse

    integer :: ierr, ncid, ierr_snodep
    integer :: idx
    real, dimension(100) :: layer_bottom
    real, dimension(100) :: layer_top

    real, dimension(xstart:xend, 4, ystart:yend) :: soildummy
    integer :: rank

#ifdef _PARALLEL_

    call MPI_COMM_RANK(MPI_COMM_WORLD, rank, ierr)
    if (ierr /= MPI_SUCCESS) stop "MPI_COMM_RANK"

    ierr = nf90_open_par(filename, NF90_NOWRITE, MPI_COMM_WORLD, MPI_INFO_NULL, ncid)
#else
    rank = 0
    ierr = nf90_open(filename, NF90_NOWRITE, ncid)
#endif
    if (rank == 0) write(*,'("filename: ''", A, "''")') trim(filename)
    if (ierr /= 0) then
       if (rank == 0) write(*,'("Problem opening netcdf file: ''", A, "''")') trim(filename)
#ifdef _PARALLEL_
       call mpi_finalize(ierr)
#endif
       stop
    endif

    ierr = nf90_get_att(ncid, NF90_GLOBAL, "TITLE", titlestr)
    if (ierr /= 0) then
       write(*,'("WARNING:  LDASIN file does not have TITLE attribute.")')
       write(*,'("          This probably means that LDASIN files are from an older release.")')
       write(*,'("          I assume you know what you are doing.")')
       ldasin_version = 0
    else
       write(*,'("LDASIN TITLE attribute: ", A)') trim(titlestr)
       ! Pull out the version number, assuming that the version is identified by vYYYYMMDD, and
       ! based on a search for the string "v20".
       idx = index(trim(titlestr), "v20")
       if (idx <= 0) then
          write(*,'("FATAL:  LDASIN file has a perverse version identifier")')
          !  write(*,'("          I assume you know what you are doing.")')
          stop
       else
          read(titlestr(idx+1:), '(I8)', iostat=ierr) ldasin_version
          if (ierr /= 0) then
             write(*,'("FATAL:  LDASIN file has a perverse version identifier")')
             !  write(*,'("          I assume you know what you are doing.")')
             stop
          endif
       endif
    endif
    write(*, '("ldasin_version = ", I8)') ldasin_version

    ierr = nf90_get_att(ncid, NF90_GLOBAL, "MMINLU", ldasin_llanduse)
    if (ierr /= 0) then
       write(*,'("WARNING:  LDASIN file does not have MMINLU attribute.")')
       write(*,'("          This probably means that LDASIN files are from an older release.")')
       write(*,'("          I assume you know what you are doing.")')
    else
       write(*,'("LDASIN MMNINLU attribute: ", A)') ldasin_llanduse
    endif

    call netcdf_get(ncid, "CANWAT", cmc, units, xstart, xend, ystart, yend, FATAL, ierr)
    call netcdf_get(ncid, "SKINTEMP", t1, units, xstart, xend, ystart, yend, FATAL, ierr)
    call netcdf_get(ncid, "WEASD", weasd, units, xstart, xend, ystart, yend, FATAL, ierr)
    if (trim(units) == "m") then
       ! No conversion necessary
    else if (trim(units) == "mm") then
       ! convert WEASD from mm to m
       weasd = weasd * 1.E-3
    else if (trim(units) == "kg m{-2}") then
       ! convert WEASD from mm to m
       weasd = weasd * 1.E-3
    else if (trim(units) == "kg/m2") then
       ! convert WEASD from mm to m
       weasd = weasd * 1.E-3
    else
       print*, 'units = "'//trim(units)//'"'
       stop "Unrecognized units on WEASD"
    endif

    snodep = 0.0
    call netcdf_get(ncid, "SNODEP", snodep, units, xstart, xend, ystart, yend, NOT_FATAL, ierr_snodep)
    fndsnowh = .true.
    if (ierr_snodep /= 0) fndsnowh = .false.


    call get_2d_netcdf_soillevel(ncid, "STEMP_1", soildummy(:,1,:), units, xstart, xend, ystart, yend, FATAL, &
         layer_bottom(1), layer_top(1), ierr)
    call get_2d_netcdf_soillevel(ncid, "STEMP_2", soildummy(:,2,:), units, xstart, xend, ystart, yend, FATAL, &
         layer_bottom(2), layer_top(2), ierr)
    call get_2d_netcdf_soillevel(ncid, "STEMP_3", soildummy(:,3,:), units, xstart, xend, ystart, yend, FATAL, &
         layer_bottom(3), layer_top(3), ierr)
    call get_2d_netcdf_soillevel(ncid, "STEMP_4", soildummy(:,4,:), units, xstart, xend, ystart, yend, FATAL, &
         layer_bottom(4), layer_top(4), ierr)
    write(*, '("layer_bottom(1:4) = ", 4F9.4)') layer_bottom(1:4)
    write(*, '("layer_top(1:4)    = ", 4F9.4)') layer_top(1:4)
    write(*, '("Soil depth = ", 10F12.6)') sldpth

    call hrldas_init_interp(xstart, xend, ystart, yend, nsoil, sldpth, stc, 4, soildummy, layer_bottom(1:4), layer_top(1:4))

    call get_2d_netcdf_soillevel(ncid, "SMOIS_1", soildummy(:,1,:), units, xstart, xend, ystart, yend, FATAL, &
         layer_bottom(1), layer_top(1), ierr)
    call get_2d_netcdf_soillevel(ncid, "SMOIS_2", soildummy(:,2,:), units, xstart, xend, ystart, yend, FATAL, &
         layer_bottom(2), layer_top(2), ierr)
    call get_2d_netcdf_soillevel(ncid, "SMOIS_3", soildummy(:,3,:), units, xstart, xend, ystart, yend, FATAL, &
         layer_bottom(3), layer_top(3), ierr)
    call get_2d_netcdf_soillevel(ncid, "SMOIS_4", soildummy(:,4,:), units, xstart, xend, ystart, yend, FATAL, &
         layer_bottom(4), layer_top(4), ierr)

    call hrldas_init_interp(xstart, xend, ystart, yend, nsoil, sldpth, smc, 4, soildummy, layer_bottom(1:4), layer_top(1:4))

    ierr = nf90_close(ncid)
  end subroutine hrldas_init_read_old


  subroutine hrldas_init_interp(xstart, xend, ystart, yend, nsoil, sldpth, var, nvar, src, layer_bottom, layer_top)
    implicit none
    integer, intent(in)    :: xstart, xend, ystart, yend, nsoil, nvar
    real, dimension(nsoil) :: sldpth ! the thickness of each layer
    real, dimension(xstart:xend, nsoil, ystart:yend), intent(out) :: var
    real, dimension(xstart:xend, nvar, ystart:yend ), intent(in)  :: src
    real, dimension(nvar),                            intent(in)  :: layer_bottom ! The depth from the surface of each layer bottom.
    real, dimension(nvar),                            intent(in)  :: layer_top    ! The depth from the surface of each layer top.
    integer :: i, j, k, kk, ktop, kbottom
    real, dimension(nsoil) :: dst_centerpoint
    real, dimension(nvar)  :: src_centerpoint
    real :: fraction
    integer :: ierr
    integer :: rank

#ifdef _PARALLEL_
    call MPI_COMM_RANK(MPI_COMM_WORLD, rank, ierr)
    if (ierr /= MPI_SUCCESS) stop "MPI_COMM_RANK"
#else
    rank = 0
#endif

    do k = 1, nsoil
       if (k==1) then
          dst_centerpoint(k) = sldpth(k)/2.
       else
          dst_centerpoint(k) = sldpth(k)/2. + sum(sldpth(1:k-1))
       endif
       if (rank == 0) print*, 'k, dst_centerpoint(k) = ', k, dst_centerpoint(k)
    enddo
    print*

    do k = 1, nvar
       src_centerpoint(k) = 0.5*(layer_bottom(k)+layer_top(k))
       if (rank == 0) print*, 'k, src_centerpoint(k) = ', k, src_centerpoint(k)
    enddo

    KLOOP : do k = 1, nsoil

       if (dst_centerpoint(k) < src_centerpoint(1)) then
          ! If the center of the destination layer is closer to the surface than
          ! the center of the topmost source layer, then simply set the
          ! value of the destination layer equal to the topmost source layer:
          if (rank == 0) then
             print'("Shallow destination layer:  Taking destination layer at ",F7.4, " from source layer at ", F7.4)', &
                  dst_centerpoint(k), src_centerpoint(1)
          endif
          var(:,k,:) = src(:,1,:)
          cycle KLOOP
       endif

       if (dst_centerpoint(k) > src_centerpoint(nvar)) then
          ! If the center of the destination layer is deeper than
          ! the center of the deepest source layer, then simply set the
          ! value of the destination layer equal to the deepest source layer:
          if (rank == 0) then
             print'("Deep destination layer:  Taking destination layer at ",F7.4, " from source layer at ", F7.4)', &
                  dst_centerpoint(k), src_centerpoint(nvar)
          endif
          var(:,k,:) = src(:,nvar,:)
          cycle KLOOP
       endif

       ! Check if the center of the destination layer is "close" to the center
       ! of a source layer.  If so, simply set the value of the destination layer
       ! equal to the value of that close soil layer:
       do kk = 1, nvar
          if (abs(dst_centerpoint(k)-src_centerpoint(kk)) < 0.01) then
             if (rank == 0) then
                print'("(Near) match for destination layer:  Taking destination layer at ",F7.4, " from source layer at ", F7.4)', &
                     dst_centerpoint(k), src_centerpoint(kk)
             endif
             var(:,k,:) = src(:,kk,:)
             cycle KLOOP
          endif
       enddo

       ! Otherwise, do a linear interpolation

       ! Get ktop, the index of the top bracketing layer from the source dataset.
       ! Which from the bottom up, will be the first source level that is closer
       ! to the surface than the destination level
       ktop = -99999
       TOPLOOP : do kk = nvar,1,-1
          if (src_centerpoint(kk) < dst_centerpoint(k)) then
             ktop = kk
             exit TOPLOOP
          endif
       enddo TOPLOOP
       if (ktop < -99998) stop "ktop problem"


       ! Get kbottom, the index of the bottom bracketing layer from the source dataset.
       ! Which, from the top down, will be the first source level that is deeper than
       ! the destination level
       kbottom = -99999
       BOTTOMLOOP : do kk = 1, nvar
          if ( src_centerpoint(kk) > dst_centerpoint(k) ) then
             kbottom = kk
             exit BOTTOMLOOP
          endif
       enddo BOTTOMLOOP
       if (kbottom < -99998) stop "kbottom problem"

       fraction = (src_centerpoint(kbottom)-dst_centerpoint(k)) / (src_centerpoint(kbottom)-src_centerpoint(ktop))

       ! print '(I2, 1x, 3F7.3, F8.5)', k, src_centerpoint(ktop), dst_centerpoint(k), src_centerpoint(kbottom), fraction

       if (rank == 0) then
          print '("dst(",I1,") = src(",I1,")*",F8.5," + src(",I1,")*",F8.5)', k, ktop, fraction, kbottom, (1.0-fraction)
       endif

       var(:,:,k) = (src(:,ktop,:)*fraction) + (src(:,kbottom,:)*(1.0-fraction))

    enddo KLOOP

  end subroutine hrldas_init_interp


  subroutine hrldas_parm_veg_read(flnm, xstart, xend, ystart, yend, target_date, vegtyp, fpar, lai, gvfmin, gvfmax)

    implicit none
    character(len=*),                                  intent(in)  :: flnm
    integer,                                           intent(in)  :: xstart, xend
    integer,                                           intent(in)  :: ystart, yend
    character(len=*),                                  intent(in)  :: target_date
    integer, dimension(xstart:xend,ystart:yend),       intent(in)  :: vegtyp
    real,    dimension(xstart:xend,ystart:yend),       intent(out) :: fpar
    real,    dimension(xstart:xend,ystart:yend),       intent(out) :: lai
    real,    dimension(xstart:xend,ystart:yend),       intent(out) :: gvfmin
    real,    dimension(xstart:xend,ystart:yend),       intent(out) :: gvfmax

    character(len=8)   :: name
    character(len=256) :: units
    integer :: ierr

    integer :: ierr_fpar
    integer :: ierr_lai

    integer :: i, j
    integer :: iret, ncid

    ! Open the NetCDF file.
    !KWM    write(*,'("flnm: ''", A, "''")') trim(flnm)
#ifdef _PARALLEL_
    iret = nf90_open_par(flnm, NF90_NOWRITE, MPI_COMM_WORLD, MPI_INFO_NULL, ncid)
#else
    iret = nf90_open(flnm, NF90_NOWRITE, ncid)
#endif
    if (iret /= 0) then
       write(*,'("hrldas_parm_veg_read:  Problem opening netcdf file: ''", A, "''")') trim(flnm)
       stop
    endif

    call netcdf_get(ncid, "VEGFRA", fpar, units, xstart, xend, ystart, yend, NOT_FATAL, ierr_fpar)
    call netcdf_get(ncid, "LAI", lai, units, xstart, xend, ystart, yend, NOT_FATAL, ierr_lai)

    if (ierr_fpar == 0) then
       ! fpar = fpar * 1.E-2 ! convert from percent to fraction
    else if (ierr_fpar /= 0) then
       ! Get it from tables
       ! print*,' hrldas_parm_veg_read:  VEGFRA not found.  Initializing FPAR from table SHDTBL.'
       do i = xstart, xend
          do j = ystart, yend
             !KWM             fpar(i,j) = shdtbl(vegtyp(i,j))
          enddo
       enddo
    endif
    if (ierr_lai /= 0) then
       ! Get it from tables
       ! print*,' hrldas_parm_veg_read:  LAI not found.  Initializing LAI from table LAITBL.'
       do i = xstart, xend
          do j = ystart, yend
             ! Fixme for wrfcode input
             !             lai(i,j) = laitbl(vegtyp(i,j))
          enddo
       enddo
    endif

    ! Get Minimum Green Vegetation Fraction GVFMIN
    call netcdf_get(ncid, "GVFMIN", gvfmin, units, xstart, xend, ystart, yend, FATAL, ierr)

    ! Get Minimum Green Vegetation Fraction GVFMAX
    call netcdf_get(ncid, "GVFMAX", gvfmax, units, xstart, xend, ystart, yend, FATAL, ierr)

    iret = nf90_close(ncid)
  end subroutine hrldas_parm_veg_read


  subroutine hrldas_input_read(flnm_template, input_timestep, target_date, xstart, xend, ystart, yend, &
       t, q, u, v, p, lw, sw, pcp, lai, fpar)
    use kwm_string_utilities
    implicit none
    character(len=*), intent(in) :: flnm_template
    integer, intent(in) :: input_timestep
    integer, intent(in) :: xstart, xend
    integer, intent(in) :: ystart, yend
    character(len=19), intent(in) :: target_date ! (YYYY-MM-DD_hh:mm:ss)
    real, dimension(xstart:xend,ystart:yend), intent(out) :: t
    real, dimension(xstart:xend,ystart:yend), intent(out) :: q
    real, dimension(xstart:xend,ystart:yend), intent(out) :: u
    real, dimension(xstart:xend,ystart:yend), intent(out) :: v
    real, dimension(xstart:xend,ystart:yend), intent(out) :: p
    real, dimension(xstart:xend,ystart:yend), intent(out) :: lw
    real, dimension(xstart:xend,ystart:yend), intent(out) :: sw
    real, dimension(xstart:xend,ystart:yend), intent(out) :: pcp
    real, dimension(xstart:xend,ystart:yend), intent(out) :: lai
    real, dimension(xstart:xend,ystart:yend), intent(inout) :: fpar

    character(len=256) :: flnm
    character(len=256) :: units
    character(len=256) :: nextflnm
    integer :: ierr
    integer :: ncid
    integer :: rank

    type(hrldas_input_t) :: lastread = hrldas_input_t("0000-00-00_00:00:00", &
         null(), null(), null(), null(), null(), null(), null(), null(), null(), null() )
    type(hrldas_input_t) :: nextread= hrldas_input_t("0000-00-00_00:00:00", &
         null(), null(), null(), null(), null(), null(), null(), null(), null(), null() )

#ifdef MPP_LAND
    call mpp_land_bcast(target_date(1:19), 19, io_id)
    call mpp_land_bcast(nextread%read_date(1:19), 19, io_id)
#endif

    if (target_date > nextread%read_date) then
       ! We've advanced beyond the date of the end-bracketing data in memory.
       ! Read the next (later) forcing data, and put the data into the nextread
       ! structure.
       if (nextread%read_date /= "0000-00-00_00:00:00") then
          ! Clear the old lastread data
          call hrldas_input_clear(lastread)

          ! Copy nextread to lastread
          lastread = nextread

          ! Clear nextread
          call hrldas_input_nullify(nextread)
       endif

       ! Guess the next read date (from the last read date and the forcing timestep).
       ! If there is no last date, assume we're at the beginning of our processing
       ! and take the target_date as the first timestep, for which forcing data
       ! must be available.

#ifdef MPP_LAND
       call mpp_land_bcast(lastread%read_date(1:19), 19, io_id)
#endif
       if (lastread%read_date == "0000-00-00_00:00:00") then
          nextread%read_date = target_date
       else
          call geth_newdate(nextread%read_date, lastread%read_date, input_timestep)
       endif

       ! Build a file name
       flnm = flnm_template
       call strrep(flnm, "<date>", &
            & nextread%read_date(1:4) // nextread%read_date(6:7) // nextread%read_date(9:10) // 'T' &
            & // nextread%read_date(12:13) // nextread%read_date(15:16) // nextread%read_date(18:19))

#ifdef MPP_LAND
       if(my_id == io_id) then
#endif
          !print*, 'read file:  ', trim(flnm)
          ! Open the NetCDF file.
          ierr = nf90_open(flnm, NF90_NOWRITE, ncid)
          if (ierr /= 0) then
             write(*,*) 'ERROR[HRLDAS_INPUT_READ]: Problem opening file '//trim(flnm)
             stop
          endif
#ifdef MPP_LAND
       endif
#endif

       ! Allocate space to hold data
       call hrldas_input_allocate(nextread, xstart, xend, ystart, yend)

       ! Read the data
       call netcdf_get(ncid, "T2D", nextread%t, units, xstart, xend, ystart, yend, FATAL, ierr)
       call netcdf_get(ncid, "Q2D", nextread%q, units, xstart, xend, ystart, yend, FATAL, ierr)
       call netcdf_get(ncid, "U2D", nextread%u, units, xstart, xend, ystart, yend, FATAL, ierr)
       call netcdf_get(ncid, "V2D", nextread%v, units, xstart, xend, ystart, yend, FATAL, ierr)
       call netcdf_get(ncid, "PSFC", nextread%p, units, xstart, xend, ystart, yend, FATAL, ierr)
       call netcdf_get(ncid, "LWDOWN", nextread%lw, units, xstart, xend, ystart, yend, FATAL, ierr)
       call netcdf_get(ncid, "SWDOWN", nextread%sw, units, xstart, xend, ystart, yend, FATAL, ierr)
       call netcdf_get(ncid, "RAINRATE", nextread%pcp, units, xstart, xend, ystart, yend, FATAL, ierr)
       call netcdf_get(ncid, "VEGFRA", nextread%fpar, units, xstart, xend, ystart, yend, NOT_FATAL, ierr)
       if (ierr /= 0) then
          ! print*, 'VEGFRA not found!'
          ! If we don't find a new VEGFRA, carry over the old one
          if (associated(lastread%fpar)) then
             nextread%fpar = lastread%fpar
          else
             nextread%fpar = fpar
          endif
       endif
       call netcdf_get(ncid, "LAI", nextread%lai, units, xstart, xend, ystart, yend, NOT_FATAL, ierr)
       if (ierr /= 0) then
          ! print*, 'LAI not found!'
          ! If we don't find a new LAI, carry over the old one
          if (associated(lastread%lai)) then
             nextread%lai = lastread%lai
          endif
       endif

#ifdef MPP_LAND
       if(my_id == io_id) &
#endif
                                ! Close the file
            ierr = nf90_close(ncid)
    endif

#ifdef MPP_LAND
    call mpp_land_bcast(target_date(1:19), 19, io_id)
#endif

    if (target_date == nextread%read_date) then
       ! We have advanced to the later date of our bracketing times for interpolation.
       ! Take that data as is, no interpolation necessary, move that data into the
       ! lastread structure, and return that data.

       ! Fill the t, q, u, v, ... arrays with data from the nextread structure.
       call hrldas_input_copy(nextread, t, q, u, v, p, lw, sw, pcp, fpar, lai, xstart, xend, ystart, yend)

       ! Clear the old lastread data
       call hrldas_input_clear(lastread)

       ! Copy nextread to lastread
       lastread = nextread

       ! Set the nextread%read_date field to signal that we need to read
       nextread%read_date = "0000-00-00_00:00:00"

       ! Clear nextread
       call hrldas_input_nullify(nextread)

    else if ((target_date > lastread%read_date) .and. (target_date < nextread%read_date)) then
       ! We are at a Noah time step between the lastread data and the available nextread data.
       ! Do temporal interpolation and return the interpolated data.  Keep lastread
       ! and nextread as they were.

       ! Fill the t, q, u, v, ... arrays with data interpolated between lastread and nextread times.
       call hrldas_input_interpolate(lastread, nextread, target_date, &
            t, q, u, v, p, lw, sw, pcp, fpar, lai, xstart, xend, ystart, yend)
    else
       write(*,*) 'ERROR[HRLDAS_INPUT_READ]: Problem with the logic of HRLDAS_INPUT_READ'
       write(*,*) 'ERROR[HRLDAS_INPUT_READ]: target_date = ' // target_date
       write(*,*) 'ERROR[HRLDAS_INPUT_READ]: lastread%read_date = ' // lastread%read_date
       write(*,*) 'ERROR[HRLDAS_INPUT_READ]: nextread%read_date = ' // nextread%read_date
       STOP
    endif
  end subroutine hrldas_input_read


  subroutine hrldas_input_allocate(instruct, xstart, xend, ystart, yend)
    implicit none
    type(hrldas_input_t) :: instruct
    integer, intent(in) :: xstart
    integer, intent(in) :: xend
    integer, intent(in) :: ystart
    integer, intent(in) :: yend

    integer :: allostat

    allocate(instruct%t(xstart:xend,ystart:yend), stat=allostat )
    if (allostat/=0) stop "Problem allocating instruct%t"

    allocate(instruct%q(xstart:xend,ystart:yend), stat=allostat )
    if (allostat/=0) stop "Problem allocating instruct%q"

    allocate(instruct%u(xstart:xend,ystart:yend), stat=allostat )
    if (allostat/=0) stop "Problem allocating instruct%u"

    allocate(instruct%v(xstart:xend,ystart:yend), stat=allostat )
    if (allostat/=0) stop "Problem allocating instruct%v"

    allocate(instruct%p(xstart:xend,ystart:yend), stat=allostat )
    if (allostat/=0) stop "Problem allocating instruct%p"

    allocate(instruct%lw(xstart:xend,ystart:yend), stat=allostat )
    if (allostat/=0) stop "Problem allocating instruct%lw"

    allocate(instruct%sw(xstart:xend,ystart:yend), stat=allostat )
    if (allostat/=0) stop "Problem allocating instruct%sw"

    allocate(instruct%pcp(xstart:xend,ystart:yend), stat=allostat )
    if (allostat/=0) stop "Problem allocating instruct%pcp"

    allocate(instruct%fpar(xstart:xend,ystart:yend), stat=allostat )
    if (allostat/=0) stop "Problem allocating instruct%fpar"

    allocate(instruct%lai(xstart:xend,ystart:yend), stat=allostat )
    if (allostat/=0) stop "Problem allocating instruct%lai"
#ifdef MPP_LAND
    instruct%lai = 0.0
#endif
  end subroutine hrldas_input_allocate


  subroutine hrldas_input_copy(instruct, t, q, u, v, p, lw, sw, pcp, fpar, lai, xstart, xend, ystart, yend)
    implicit none
    type(hrldas_input_t), intent(in) :: instruct
    integer, intent(in) :: xstart, xend, ystart, yend
    real, dimension(xstart:xend,ystart:yend), intent(out) :: t, q, u, v, p, lw, sw, pcp, fpar, lai
    t    = instruct%t
    q    = instruct%q
    u    = instruct%u
    v    = instruct%v
    p    = instruct%p
    lw   = instruct%lw
    sw   = instruct%sw
    pcp  = instruct%pcp
    fpar = instruct%fpar
    lai  = instruct%lai
  end subroutine hrldas_input_copy


  subroutine hrldas_input_interpolate(instructA, instructB, target_date, &
       t, q, u, v, p, lw, sw, pcp, fpar, lai, xstart, xend, ystart, yend)
    implicit none
    type(hrldas_input_t), intent(in) :: instructA, instructB
    character(len=19), intent(in) :: target_date
    integer, intent(in) :: xstart, xend, ystart, yend
    real, dimension(xstart:xend,ystart:yend), intent(out) :: t
    real, dimension(xstart:xend,ystart:yend), intent(out) :: q
    real, dimension(xstart:xend,ystart:yend), intent(out) :: u
    real, dimension(xstart:xend,ystart:yend), intent(out) :: v
    real, dimension(xstart:xend,ystart:yend), intent(out) :: p
    real, dimension(xstart:xend,ystart:yend), intent(out) :: lw
    real, dimension(xstart:xend,ystart:yend), intent(out) :: sw
    real, dimension(xstart:xend,ystart:yend), intent(out) :: pcp
    real, dimension(xstart:xend,ystart:yend), intent(out) :: fpar
    real, dimension(xstart:xend,ystart:yend), intent(out) :: lai

    integer :: idts, idts2
    real :: fraction

    call geth_idts(target_date, instructA%read_date, idts)
    call geth_idts(instructB%read_date, instructA%read_date, idts2)

    fraction = real(idts2-idts)/real(idts2)
    t  = (instructA%t  * fraction) + (instructB%t  * (1.0-fraction))
    q  = (instructA%q  * fraction) + (instructB%q  * (1.0-fraction))
    u  = (instructA%u  * fraction) + (instructB%u  * (1.0-fraction))
    v  = (instructA%v  * fraction) + (instructB%v  * (1.0-fraction))
    p  = (instructA%p  * fraction) + (instructB%p  * (1.0-fraction))
    lw = (instructA%lw * fraction) + (instructB%lw * (1.0-fraction))
    sw = (instructA%sw * fraction) + (instructB%sw * (1.0-fraction))
    pcp = instructA%pcp
    fpar = instructA%fpar
    lai  = instructA%lai
  end subroutine hrldas_input_interpolate


  subroutine hrldas_input_clear(instruct)
    implicit none
    type(hrldas_input_t) :: instruct

    if (associated(instruct%t)) then
       deallocate(instruct%t)
       nullify(instruct%t)
    endif

    if (associated(instruct%q)) then
       deallocate(instruct%q)
       nullify(instruct%q)
    endif

    if (associated(instruct%u)) then
       deallocate(instruct%u)
       nullify(instruct%u)
    endif

    if (associated(instruct%v)) then
       deallocate(instruct%v)
       nullify(instruct%v)
    endif

    if (associated(instruct%p)) then
       deallocate(instruct%p)
       nullify(instruct%p)
    endif

    if (associated(instruct%lw)) then
       deallocate(instruct%lw)
       nullify(instruct%lw)
    endif

    if (associated(instruct%sw)) then
       deallocate(instruct%sw)
       nullify(instruct%sw)
    endif

    if (associated(instruct%pcp)) then
       deallocate(instruct%pcp)
       nullify(instruct%pcp)
    endif

    if (associated(instruct%fpar)) then
       deallocate(instruct%fpar)
       nullify(instruct%fpar)
    endif

    if (associated(instruct%lai)) then
       deallocate(instruct%lai)
       nullify(instruct%lai)
    endif
  end subroutine hrldas_input_clear


  subroutine hrldas_input_nullify(instruct)
    implicit none
    type(hrldas_input_t) :: instruct

    nullify(instruct%t)
    nullify(instruct%q)
    nullify(instruct%u)
    nullify(instruct%v)
    nullify(instruct%p)
    nullify(instruct%lw)
    nullify(instruct%sw)
    nullify(instruct%pcp)
    nullify(instruct%fpar)
    nullify(instruct%lai)
  end subroutine hrldas_input_nullify


  subroutine hrldas_readsnow(flnm,xstart,xend,ystart,yend,target_date,weasd,snodep)
    implicit none

    character(len=*),                                     intent(in)  :: flnm
    integer,                                              intent(in)  :: xstart, xend
    integer,                                              intent(in)  :: ystart, yend
    character(len=*),                                     intent(in)  :: target_date
    real,             dimension(xstart:xend,ystart:yend), intent(out) :: weasd
    real,             dimension(xstart:xend,ystart:yend), intent(out) :: snodep

    character(len=256) :: units
    integer :: ierr
    integer :: ncid

    ! Open the NetCDF file.

#ifdef _PARALLEL_
    ierr = nf90_open_par(flnm, NF90_NOWRITE, MPI_COMM_WORLD, MPI_INFO_NULL, ncid)
#else
    ierr = nf90_open(flnm, NF90_NOWRITE, ncid)
#endif
    if (ierr /= 0) then
       write(*,'("hrldas_readsnow:  Problem opening netcdf file: ''", A, "''")') trim(flnm)
       stop
    endif

    call netcdf_get(ncid, "WEASD", weasd, units, xstart, xend, ystart, yend, FATAL, ierr)

    if (trim(units) == "m") then
       ! No conversion necessary
    else if (trim(units) == "mm") then
       ! convert WEASD from mm to m
       weasd = weasd * 1.E-3
    else if (trim(units) == "kg m-2") then
       ! convert WEASD from mm to m
       weasd = weasd * 1.E-3
    else if (trim(units) == "kg/m2") then
       ! convert WEASD from mm to m
       weasd = weasd * 1.E-3
    else
       print*, 'units = "'//trim(units)//'"'
       stop "Unrecognized units on WEASD"
    endif

    call netcdf_get(ncid, "SNODEP", snodep, units, xstart, xend, ystart, yend, NOT_FATAL, ierr)

    if (ierr /= 0) then
       ! Quick assumption regarding snow depth.
       snodep = weasd * 10.
    endif

    ierr = nf90_close(ncid)

  end subroutine hrldas_readsnow


#ifdef MPP_LAND
  subroutine hrldas_output_prepare_mpp(outdir, version, &
       output_timestep, llanduse, &
       ixfull, jxfull, ixpar, jxpar, xstartpar, ystartpar, iswater, &
       mapproj, dx, dy, truelat1, truelat2, cen_lon, &
       nsoil, nsnow, sldpth, startdate, date, &
       vegtyp, soltyp)

    implicit none

    character(len=*),                         intent(in) :: outdir
    character(len=*),                         intent(in) :: version
    integer,                                  intent(in) :: output_timestep
    character(len=*),                         intent(in) :: llanduse
    integer,                                  intent(in) :: ixfull
    integer,                                  intent(in) :: jxfull
    integer,                                  intent(in) :: ixpar
    integer,                                  intent(in) :: jxpar
    integer,                                  intent(in) :: xstartpar
    integer,                                  intent(in) :: ystartpar
    integer,                                  intent(in) :: iswater
    integer,                                  intent(in) :: mapproj
    real,                                     intent(in) :: dx
    real,                                     intent(in) :: dy
    real,                                     intent(in) :: truelat1
    real,                                     intent(in) :: truelat2
    real,                                     intent(in) :: cen_lon
    integer,                                  intent(in) :: nsoil
    integer,                                  intent(in) :: nsnow
    real,             dimension(nsoil),       intent(in) :: sldpth
    character(len=19),                        intent(in) :: startdate
    character(len=19),                        intent(in) :: date
    integer,          dimension(ixpar,jxpar), intent(in) :: vegtyp
    integer,          dimension(ixpar,jxpar), intent(in) :: soltyp
    integer,          dimension(global_nx,global_ny) :: g_vegtyp
    integer,          dimension(global_nx,global_ny) :: g_soltyp


    call write_io_int(vegtyp, g_vegtyp)
    call write_io_int(soltyp, g_soltyp)

    if(my_id .eq. IO_id) then
       call hrldas_output_prepare_seq(outdir, version, &
            output_timestep, llanduse, &
            global_nx, global_ny, global_nx, global_ny, xstartpar, ystartpar, iswater,  &
            mapproj, dx, dy, truelat1, truelat2, cen_lon,     &
            nsoil, nsnow, sldpth, startdate, date, &
            g_vegtyp, g_soltyp)
    end if

  end subroutine hrldas_output_prepare_mpp
#endif

  subroutine hrldas_output_prepare_seq(outdir, version, &
       output_timestep, llanduse, &
       ixfull, jxfull, ixpar, jxpar, xstartpar, ystartpar, iswater, &
       mapproj, dx, dy, truelat1, truelat2, cen_lon, &
       nsoil, nsnow, sldpth, startdate, date, &
       vegtyp, soltyp)
    ! To prepare the output file, we create the file, write dimensions and attributes, write the time variable.
    ! At the end of this routine, the output file is out of define mode.
    implicit none
#include <netcdf.inc>

    character(len=*),                         intent(in) :: outdir
    character(len=*),                         intent(in) :: version
    integer,                                  intent(in) :: output_timestep
    character(len=*),                         intent(in) :: llanduse
    integer,                                  intent(in) :: ixfull
    integer,                                  intent(in) :: jxfull
    integer,                                  intent(in) :: ixpar
    integer,                                  intent(in) :: jxpar
    integer,                                  intent(in) :: xstartpar
    integer,                                  intent(in) :: ystartpar
    integer,                                  intent(in) :: iswater
    integer,                                  intent(in) :: mapproj
    real,                                     intent(in) :: dx
    real,                                     intent(in) :: dy
    real,                                     intent(in) :: truelat1
    real,                                     intent(in) :: truelat2
    real,                                     intent(in) :: cen_lon
    integer,                                  intent(in) :: nsoil
    integer,                                  intent(in) :: nsnow
    real,             dimension(nsoil),       intent(in) :: sldpth
    character(len=19),                        intent(in) :: startdate
    character(len=19),                        intent(in) :: date
    integer,          dimension(ixpar,jxpar), intent(in) :: vegtyp
    integer,          dimension(ixpar,jxpar), intent(in) :: soltyp

    integer :: ncid

    integer :: dimid_ix, dimid_jx, dimid_times, dimid_datelen, varid, n
    integer :: dimid_dum, dimid_layers, dimid_snow_layers
    integer :: iret
    character(len=256) :: output_flnm
    character(len=19)  :: date19

    integer :: ierr

    if (output_count_remember == 0) then
       ! If this is a new output file:
       !   We have to create a new file, do dimension initializations, and write global attributes to the file.
       !   Then we get out of define mode.
       write(output_flnm, '(A,"/output.",A4,A2,A2,"T",A2,A2,A2)') outdir, &
            & date(1:4), date(6:7), date(9:10), date(12:13), date(15:16), date(18:19)
#ifdef _PARALLEL_
       iret = nf90_create(trim(output_flnm), &
            OR(NF90_CLOBBER, NF90_NETCDF4), ncid, comm=MPI_COMM_WORLD, info=MPI_INFO_NULL)
#else
#ifdef WRFIO_NCD_LARGE_FILE_SUPPORT
       iret = nf90_create(trim(output_flnm), IOR(NF90_CLOBBER,NF90_NETCDF4), ncid)
#else
       iret = nf90_create(trim(output_flnm), IOR(NF90_CLOBBER,NF90_NETCDF4), ncid)
#endif
#endif
       call error_handler(iret, failure="Problem nf90_create for "//trim(output_flnm))

       ncid_remember = ncid
       define_mode_remember = .TRUE.

       iret = nf90_def_dim(ncid, "Time", NF90_UNLIMITED, dimid_times)
       iret = nf90_def_dim(ncid, "DateStrLen", 19, dimid_datelen)
       ! Dimensions reflect the full size of the subwindow (not the strip known by this particular process).
       iret = nf90_def_dim(ncid, "west_east", ixfull, dimid_ix)
       iret = nf90_def_dim(ncid, "south_north", jxfull, dimid_jx)
       iret = nf90_def_dim(ncid, "west_east_stag", ixfull+1, dimid_dum)
       iret = nf90_def_dim(ncid, "south_north_stag", jxfull+1, dimid_dum)
       iret = nf90_def_dim(ncid, "soil_layers_stag", nsoil, dimid_layers)
       iret = nf90_def_dim(ncid, "snow_layers", nsnow, dimid_snow_layers)

       iret = nf90_put_att(ncid, NF90_GLOBAL, "TITLE", "OUTPUT FROM HRLDAS "//version)
       iret = nf90_put_att(ncid, NF90_GLOBAL, "missing_value", -1.E33)

       ! TODO:  Add Grid information   (should look more-or-less like wrfout files)
       ! TODO:  Add Units information  (should look more-or-less like wrfout files)

       date19(1:19) = "0000-00-00_00:00:00"
       date19(1:len_trim(startdate)) = startdate

       iret = nf90_put_att(ncid, NF90_GLOBAL, "START_DATE", date19)
       iret = nf90_put_att(ncid, NF90_GLOBAL, "MAP_PROJ", mapproj)
       iret = nf90_put_att(ncid, NF90_GLOBAL, "DX", dx)
       iret = nf90_put_att(ncid, NF90_GLOBAL, "DY", dy)
       iret = nf90_put_att(ncid, NF90_GLOBAL, "TRUELAT1", truelat1)
       iret = nf90_put_att(ncid, NF90_GLOBAL, "TRUELAT2", truelat2)
       iret = nf90_put_att(ncid, NF90_GLOBAL, "STAND_LON", cen_lon)
       iret = nf90_put_att(ncid, NF90_GLOBAL, "MMINLU", llanduse)

       !
       ! Done with dimensions and global attributes.
       ! Now define and describe our "Times" variable.
       !

       iret = nf90_def_var(ncid,  "Times",  NF90_CHAR, (/dimid_datelen,dimid_times/), varid, deflate_level=6)
       call error_handler(iret, failure="Problem nf90_def_var for "//trim(output_flnm))

       iret = nf90_enddef(ncid)
       call error_handler(iret, failure="Problem nf90_enddef")
       define_mode_remember = .FALSE.

    endif
    xstartpar_remember = xstartpar
    dimid_ix_remember = dimid_ix
    dimid_jx_remember = dimid_jx
    dimid_times_remember = dimid_times
    dimid_layers_remember = dimid_layers
    dimid_snow_layers_remember = dimid_snow_layers
    iswater_remember = iswater

    allocate(vegtyp_remember(ixpar,jxpar))
    vegtyp_remember = vegtyp

    !
    ! While we're here, put the data for the "Times" variable to the NetCDF file.
    !

    date19(1:19) = "0000-00-00_00:00:00"
    date19(1:len_trim(date)) = date
    iret = nf90_inq_varid(ncid_remember, "Times", varid)
    call error_handler(iret, "OUTPUT_HRLDAS:  Problem inquiring on 'Times'")

    iret = nf90_put_var(ncid_remember, varid, date, (/1,output_count_remember+1/), (/19,1/))
    call error_handler(iret, "OUTPUT_HRLDAS:  Problem writing variable 'Times'")

  end subroutine hrldas_output_prepare_seq


  subroutine hrldas_output_definemode(imode)
    implicit none
    integer, intent(in) :: imode
    integer :: ierr

#ifdef MPP_LAND
    if(my_id .ne. io_id) return
#endif

    if (imode == 1) then
       ! We need to define things only with a new file, i.e., only when output_count_remember == 0
       if (output_count_remember > 0) return
       ierr = nf90_redef(ncid_remember)
       call error_handler(ierr, failure="Problem nf90_redef")
       define_mode_remember = .TRUE.
    else
       if (define_mode_remember) then
          ierr = nf90_enddef(ncid_remember)
          call error_handler(ierr, failure="Problem nf90_enddef")
          define_mode_remember = .FALSE.
       endif
    endif

  end subroutine hrldas_output_definemode


  subroutine hrldas_output_finalize(split_output_count)
    implicit none
    integer, intent(in)  :: split_output_count
    integer :: ierr

#ifdef MPP_LAND
    if(my_id .ne. io_id) return
#endif

    output_count_remember = output_count_remember + 1
    if (output_count_remember == split_output_count) then
       output_count_remember = 0
       ierr = nf90_close(ncid_remember)
       call error_handler(ierr, failure="Problem nf90_close for output file")
    else
       ierr = nf90_sync(ncid_remember)
       call error_handler(ierr, failure="Problem nf90_sync for output file")
    endif

    deallocate(vegtyp_remember)

  end subroutine hrldas_output_finalize


#ifdef MPP_LAND
  subroutine hrldas_output_add_real2d_mpp(array, name, description, units)
    implicit none
    real, dimension(:,:), intent(in) :: array
    real, dimension(global_nx,global_ny) :: garray
    character(len=*), intent(in) :: name, description, units
    call write_io_real(array,garray)
    if(my_id .eq. io_id) then
       call hrldas_output_add_real2d(garray, name, description, units)
    endif
  end subroutine hrldas_output_add_real2d_mpp


  subroutine hrldas_output_add_integer2d_mpp(array, name, description, units)
    implicit none
    integer, dimension(:,:), intent(in) :: array
    character(len=*), intent(in) :: name, description, units
    integer, dimension(global_nx,global_ny) :: garray
    call write_io_int(array,garray)
    if(my_id .eq. io_id) then
       call hrldas_output_add_integer2d(garray, name, description, units)
    endif
  end subroutine hrldas_output_add_integer2d_mpp


  subroutine hrldas_output_add_3d_mpp(array, name, description, units, snow_or_soil)
    implicit none
    real, dimension(:,:,:), intent(in) :: array
    character(len=*), intent(in) :: name, description, units
    character(len=4), intent(in) :: snow_or_soil
    integer :: k, klevel

    real, allocatable, dimension(:,:,:) :: garray
    klevel = size(array,2)

    allocate(garray(global_nx,klevel,global_ny))

    call write_io_real3d(array,garray,klevel)
    if(my_id .eq. io_id) then
       call hrldas_output_add_3d( garray, name, description, units, snow_or_soil )
    endif
    deallocate(garray)

  end subroutine hrldas_output_add_3d_mpp
#endif


  subroutine hrldas_output_add_real2d(array, name, description, units)
    implicit none
    real, dimension(:,:), intent(in) :: array
    character(len=*), intent(in) :: name, description, units
    integer :: ixpar, jxpar

    if (define_mode_remember) then
       call make_var_att_2d ( ncid_remember , dimid_ix_remember , dimid_jx_remember , dimid_times_remember , &
            NF90_FLOAT , trim(name) , trim(description) , trim(units) )
    else
       ixpar = size(array,1)
       jxpar = size(array,2)
       call put_var_2d (ncid_remember , output_count_remember+1 , vegtyp_remember , iswater_remember , &
            ixpar , jxpar , xstartpar_remember , trim(name) , array, .false. )
    endif
  end subroutine hrldas_output_add_real2d



  subroutine hrldas_output_add_integer2d(array, name, description, units)
    implicit none
    integer, dimension(:,:), intent(in) :: array
    character(len=*), intent(in) :: name, description, units
    integer :: ixpar, jxpar

    if (define_mode_remember) then
       call make_var_att_2d ( ncid_remember , dimid_ix_remember , dimid_jx_remember , dimid_times_remember , &
            NF90_INT , trim(name) , trim(description) , trim(units) )
    else
       ixpar = size(array,1)
       jxpar = size(array,2)
       call put_var_int (ncid_remember , output_count_remember+1 , vegtyp_remember , iswater_remember , &
            ixpar , jxpar , xstartpar_remember , trim(name) , array )
    endif
  end subroutine hrldas_output_add_integer2d


  subroutine hrldas_output_add_3d(array, name, description, units, snow_or_soil)
    implicit none
    real, dimension(:,:,:), intent(in) :: array
    character(len=*), intent(in) :: name, description, units
    character(len=4), intent(in) :: snow_or_soil
    integer :: ixpar, jxpar, kxpar
    integer :: zdimid

    if (define_mode_remember) then
       if (snow_or_soil == "SOIL") then
          zdimid = dimid_layers_remember
       elseif (snow_or_soil == "SNOW") then
          zdimid = dimid_snow_layers_remember
       else
          write(*,'("SNOW_OR_SOIL unrecognized: ", A)') adjustl(trim(snow_or_soil))
          stop "SNOW_OR_SOIL"
       endif
       call make_var_att_3d ( ncid_remember , dimid_ix_remember , dimid_jx_remember , dimid_times_remember , &
            NF90_FLOAT , zdimid, trim(name) , trim(description) , trim(units) )
    else

       ixpar = size(array,1)
       kxpar = size(array,2)
       jxpar = size(array,3)

       call put_var_3d (ncid_remember , output_count_remember+1 , vegtyp_remember , iswater_remember , &
            ixpar , jxpar , xstartpar_remember , kxpar, trim(name) , array )
    endif
  end subroutine hrldas_output_add_3d


  subroutine make_var_att_2d(ncid, dimid_ix, dimid_jx, dimid_times, itype, varname, vardesc, varunits)
    implicit none
    integer,          intent(in) :: ncid
    character(len=*), intent(in) :: varname
    character(len=*), intent(in) :: vardesc
    character(len=*), intent(in) :: varunits
    integer,          intent(in) :: dimid_ix
    integer,          intent(in) :: dimid_jx
    integer,          intent(in) :: dimid_times
    integer,          intent(in) :: itype
    integer :: iret
    integer :: varid

    iret = nf90_def_var(ncid,  varname,   itype, (/dimid_ix,dimid_jx,dimid_times/), varid, deflate_level=6)
    call error_handler(iret, "MAKE_VAR_ATT_2D: Failure defining variable "//trim(varname))

    iret = nf90_put_att(ncid, varid, "MemoryOrder", "XY ")
    call error_handler(iret, "MAKE_VAR_ATT_2D: Failure adding MemoryOrder attribute to variable "//trim(varname))

    iret = nf90_put_att(ncid, varid, "description", vardesc)
    call error_handler(iret, "MAKE_VAR_ATT_2D: Failure adding description attribute to variable "//trim(varname))

    iret = nf90_put_att(ncid, varid, "units", varunits)
    call error_handler(iret, "MAKE_VAR_ATT_2D: Failure adding units attribute '"//trim(varunits)//"' to variable "//trim(varname))

    iret = nf90_put_att(ncid, varid, "stagger", "-")
    call error_handler(iret, "MAKE_VAR_ATT_2D: Failure adding stagger attribute to variable "//trim(varname))

  end subroutine make_var_att_2d


  subroutine make_var_att_3d(ncid, dimid_ix, dimid_jx, dimid_times, itype, dimid_layers, varname, vardesc, varunits)
    implicit none
    integer,          intent(in) :: ncid
    character(len=*), intent(in) :: varname
    character(len=*), intent(in) :: vardesc
    character(len=*), intent(in) :: varunits
    integer,          intent(in) :: dimid_ix
    integer,          intent(in) :: dimid_jx
    integer,          intent(in) :: dimid_times
    integer,          intent(in) :: dimid_layers
    integer,          intent(in) :: itype
    integer :: iret
    integer :: varid

    iret = nf90_def_var(ncid,  varname, itype, (/dimid_ix,dimid_layers,dimid_jx,dimid_times/), varid, deflate_level=6)
    call error_handler(iret, "MAKE_VAR_ATT_3D:  Failure defining variable "//trim(varname))

    iret = nf90_put_att(ncid, varid, "MemoryOrder", "XZY")
    call error_handler(iret, "MAKE_VAR_ATT_3D: Failure adding MemoryOrder attribute for variable "//trim(varname))

    iret = nf90_put_att(ncid, varid, "description", vardesc)
    call error_handler(iret, "MAKE_VAR_ATT_3D: Failure adding description attribute to variable "//trim(varname))

    iret = nf90_put_att(ncid, varid, "units", varunits)
    call error_handler(iret, "MAKE_VAR_ATT_3D: Failure adding units attribute '"//trim(varunits)//"' to variable "//trim(varname))

    iret = nf90_put_att(ncid, varid, "stagger", "Z")
    call error_handler(iret, "MAKE_VAR_ATT_3D: Failure adding stagger attribute to variable "//trim(varname))

  end subroutine make_var_att_3d


  subroutine put_var_2d(ncid, output_count, vegtyp, iswater, ix, jx, xstart, varname, vardata, restart_flag)
    implicit none
    integer,                   intent(in) :: ncid
    integer,                   intent(in) :: output_count
    character(len=*),          intent(in) :: varname
    integer,                   intent(in) :: ix
    integer,                   intent(in) :: jx
    integer,                   intent(in) :: xstart
    integer, dimension(ix,jx), intent(in) :: vegtyp
    integer,                   intent(in) :: iswater
    real,    dimension(ix,jx), intent(in) :: vardata
    logical,                   intent(in) :: restart_flag

    real,    dimension(ix,jx)             :: xdum
    integer                               :: iret
    integer                               :: varid

    integer, dimension(3) :: nstart
    integer, dimension(3) :: ncount

    where (vegtyp == ISWATER .and. .not. restart_flag)
       xdum = -1.E33
    elsewhere
       xdum = vardata
    endwhere

    iret = nf90_inq_varid(ncid,  varname, varid)
    call error_handler(iret, "Subroutine PUT_VAR_2D:  Problem finding variable id for "//trim(varname)//".")

    nstart = (/ xstart ,  1 , output_count /)
    ncount = (/     ix , jx ,            1 /)

    iret = nf90_put_var(ncid, varid, xdum, start=nstart, count=ncount)
    call error_handler(iret, "Subroutine PUT_VAR_2D:  Problem putting variable "//trim(varname)//" to NetCDF file.")

  end subroutine put_var_2d


  subroutine put_var_int(ncid, output_count, vegtyp, iswater, ix, jx, xstart, varname, vardata)
    implicit none
    integer,                                              intent(in) :: ncid
    integer,                                              intent(in) :: output_count
    character(len=*),                                     intent(in) :: varname
    integer,                                              intent(in) :: ix
    integer,                                              intent(in) :: jx
    integer,                                              intent(in) :: xstart
    integer,                                              intent(in) :: iswater
    integer, dimension(ix,jx),                            intent(in) :: vegtyp
    integer, dimension(ix,jx),                            intent(in) :: vardata

    integer                                                          :: iret
    integer                                                          :: varid

    integer, dimension(3)                                            :: nstart
    integer, dimension(3)                                            :: ncount

    nstart = (/ xstart ,  1 , output_count /)
    ncount = (/     ix , jx ,            1 /)

    iret = nf90_inq_varid(ncid,  varname, varid)
    call error_handler(iret, failure="Subroutine PUT_VAR_INT:  Problem finding variable id for variable: "//varname)

    iret = nf90_put_var(ncid, varid, vardata, nstart, ncount)
    call error_handler(iret, failure="Subroutine PUT_VAR_INT:  Problem putting variable '"//varname//"' to NetCDF file.")

  end subroutine put_var_int


  subroutine put_var_3d(ncid, output_count, vegtyp, iswater, ix, jx, xstart, nsoil, varname, vardata)
    implicit none
    integer,                                                    intent(in) :: ncid
    integer,                                                    intent(in) :: output_count
    character(len=*),                                           intent(in) :: varname
    integer,                                                    intent(in) :: ix
    integer,                                                    intent(in) :: jx
    integer,                                                    intent(in) :: xstart
    integer,                                                    intent(in) :: nsoil
    integer,                                                    intent(in) :: iswater
    integer, dimension(ix, jx),                                 intent(in) :: vegtyp
    real,    dimension(ix, nsoil, jx),                          intent(in) :: vardata
    real,    dimension(ix, nsoil, jx)                                      :: xdum
    integer                                                                :: iret
    integer                                                                :: varid
    integer                                                                :: n
    integer, dimension(4)                                                  :: nstart
    integer, dimension(4)                                                  :: ncount

    nstart = (/ xstart ,  1 ,     1 , output_count /)
    ncount = (/     ix , nsoil , jx ,            1 /)

    xdum = vardata
    do n = 1, nsoil
       where (vegtyp(:,:) == ISWATER) xdum(:,n,:) = -1.E33
    enddo

    iret = nf90_inq_varid(ncid,  varname, varid)
    call error_handler(iret, "Subroutine PUT_VAR_3D:  Problem finding variable id for "//trim(varname)//".")

    iret = nf90_put_var(ncid, varid, xdum, start=nstart, count=ncount)
    call error_handler(iret, "Subroutine PUT_VAR_3D:  Problem putting variable "//trim(varname)//" to NetCDF file.")

  end subroutine put_var_3d


  subroutine hrldas_restart_finalize()
    implicit none

    if(allocated(vegtyp_remember)) deallocate(vegtyp_remember)
    restart_filename_remember = " "
    iswater_remember   = -999999
    xstartpar_remember = -999999
  end subroutine hrldas_restart_finalize


#ifdef MPP_LAND
  subroutine hrldas_restart_prepare_mpp(outdir, version, llanduse, olddate, startdate, &
       ixfull, jxfull, ixpar, jxpar, xstartpar, ystartpar, &
       nsoil, nsnow, dx, dy, truelat1, truelat2, mapproj, cen_lon, &
       iswater, vegtyp)

    implicit none

    character(len=*),                      intent(in) :: outdir
    character(len=*),                      intent(in) :: version
    character(len=*),                      intent(in) :: llanduse
    character(len=*),                      intent(in) :: olddate
    character(len=*),                      intent(in) :: startdate
    integer,                               intent(in) :: ixfull
    integer,                               intent(in) :: jxfull
    integer,                               intent(in) :: ixpar
    integer,                               intent(in) :: jxpar
    integer,                               intent(in) :: xstartpar
    integer,                               intent(in) :: ystartpar
    integer,                               intent(in) :: nsoil
    integer,                               intent(in) :: nsnow
    real,                                  intent(in) :: dx, dy
    real,                                  intent(in) :: truelat1, truelat2
    integer,                               intent(in) :: mapproj
    real,                                  intent(in) :: cen_lon
    integer,                               intent(in) :: iswater
    integer, dimension(ixpar,jxpar),       intent(in) :: vegtyp
    integer, dimension(global_nx,global_ny) :: gvegtyp

    call write_io_int(vegtyp, gvegtyp)
    if(my_id .eq. io_id) then
       call hrldas_restart_prepare_seq(outdir, version, llanduse, olddate, startdate,&
            global_nx, global_ny, global_nx, global_ny, xstartpar, ystartpar, &
            nsoil, nsnow, dx, dy, truelat1, truelat2, mapproj, cen_lon, &
            iswater, gvegtyp)
    endif

    call mpp_land_sync()

  end subroutine hrldas_restart_prepare_mpp
#endif

  subroutine hrldas_restart_prepare_seq(outdir, version, llanduse, olddate, startdate, &
       ixfull, jxfull, ixpar, jxpar, xstartpar, ystartpar, &
       nsoil, nsnow, dx, dy, truelat1, truelat2, mapproj, cen_lon, &
       iswater, vegtyp)

    implicit none
#include <netcdf.inc>

    character(len=*),                      intent(in) :: outdir
    character(len=*),                      intent(in) :: version
    character(len=*),                      intent(in) :: llanduse
    character(len=*),                      intent(in) :: olddate
    character(len=*),                      intent(in) :: startdate
    integer,                               intent(in) :: ixfull
    integer,                               intent(in) :: jxfull
    integer,                               intent(in) :: ixpar
    integer,                               intent(in) :: jxpar
    integer,                               intent(in) :: xstartpar
    integer,                               intent(in) :: ystartpar
    integer,                               intent(in) :: nsoil
    integer,                               intent(in) :: nsnow
    real,                                  intent(in) :: dx, dy
    real,                                  intent(in) :: truelat1, truelat2
    integer,                               intent(in) :: mapproj
    real,                                  intent(in) :: cen_lon
    integer,                               intent(in) :: iswater
    integer, dimension(ixpar,jxpar),       intent(in) :: vegtyp

    integer :: ncid
    character(len=256) :: filename
    integer :: ierr
    integer :: varid
    integer :: dimid_times, dimid_datelen, dimid_ix, dimid_jx, dimid_dum, dimid_layers, dimid_snow_layers, dimid_sosn_layers
    character(len=19) :: date19
    integer :: rank

#ifdef _PARALLEL_

    call MPI_COMM_RANK(MPI_COMM_WORLD, rank, ierr)
    if (ierr /= MPI_SUCCESS) stop "MPI_COMM_RANK"

#else

    rank = 0

#endif


    write(filename, '(A,"/restart.",A4,A2,A2,"T",A2,A2,A2)') trim(outdir), &
         & olddate(1:4), olddate(6:7), olddate(9:10), olddate(12:13), olddate(15:16), olddate(18:19)
    if (rank==0) print*, 'restart_filename = "'//trim(filename)//'"'

    restart_filename_remember = filename
    iswater_remember   = iswater
    xstartpar_remember = xstartpar
    allocate(vegtyp_remember(ixpar,jxpar))
    vegtyp_remember = vegtyp

#ifdef _PARALLEL_

    ierr = nf90_create(trim(filename), &
         OR(NF90_CLOBBER, NF90_NETCDF4), ncid, comm=MPI_COMM_WORLD, info=MPI_INFO_NULL)
#else
#ifdef WRFIO_NCD_LARGE_FILE_SUPPORT
    ierr = nf90_create(trim(filename), IOR(NF90_CLOBBER,NF90_NETCDF4), ncid)
#else
    ierr = nf90_create(trim(filename), IOR(NF90_CLOBBER,NF90_NETCDF4), ncid)
#endif
#endif

    if (ierr /= 0) stop "Problem nf_create"

    ierr = nf90_def_dim(ncid, "Time", NF90_UNLIMITED, dimid_times)
    ierr = nf90_def_dim(ncid, "DateStrLen", 19, dimid_datelen)
    ierr = nf90_def_dim(ncid, "west_east", ixfull, dimid_ix)
    ierr = nf90_def_dim(ncid, "south_north", jxfull, dimid_jx)
    ierr = nf90_def_dim(ncid, "west_east_stag", ixfull+1, dimid_dum)
    ierr = nf90_def_dim(ncid, "south_north_stag", jxfull+1, dimid_dum)
    ierr = nf90_def_dim(ncid, "soil_layers_stag", nsoil, dimid_layers)
    ierr = nf90_def_dim(ncid, "snow_layers", nsnow, dimid_snow_layers)
    ierr = nf90_def_dim(ncid, "sosn_layers", nsnow+nsoil, dimid_sosn_layers)

    ierr = nf90_put_att(ncid, NF90_GLOBAL, "TITLE", "RESTART FILE FROM HRLDAS "//version)
    ierr = nf90_put_att(ncid, NF90_GLOBAL, "missing_value", -1.E33)

    date19(1:19) = "0000-00-00_00:00:00"
    date19(1:len_trim(startdate)) = startdate

    ierr = nf90_put_att(ncid, NF90_GLOBAL, "START_DATE", date19)
    ierr = nf90_put_att(ncid, NF90_GLOBAL, "MAP_PROJ", mapproj)
    ierr = nf90_put_att(ncid, NF90_GLOBAL, "DX", dx)
    ierr = nf90_put_att(ncid, NF90_GLOBAL, "DY", dy)
    ierr = nf90_put_att(ncid, NF90_GLOBAL, "TRUELAT1", truelat1)
    ierr = nf90_put_att(ncid, NF90_GLOBAL, "TRUELAT2", truelat2)
    ierr = nf90_put_att(ncid, NF90_GLOBAL, "STAND_LON", cen_lon)
    ierr = nf90_put_att(ncid, NF90_GLOBAL, "MMINLU", llanduse)

    !
    ! Done with dimensions and global attributes.
    ! Now define and describe all our NetCDF restart variables.
    !

    ierr = nf90_def_var(ncid,  "Times",  NF90_CHAR, (/dimid_datelen,dimid_times/), varid, deflate_level=6)
    ierr = nf90_enddef(ncid)

    !
    ! Done defining and describing all our NetCDF restart variables.
    ! Now actually put the data for each variable into the NetCDF file.
    !

    date19(1:19) = "0000-00-00_00:00:00"
    date19(1:len_trim(olddate)) = olddate

    ierr = nf90_inq_varid(ncid, "Times", varid)
    call error_handler(ierr, "WRITE_RESTART:  Problem inquiring varid for 'Times'")

    write(6,*) "olddate  = ", olddate

    ierr = nf90_put_var(ncid, varid, olddate, (/1,1/), (/19,1/))
    call error_handler(ierr, "WRITE_RESTART:  problem putting 'Times' to restart file")

    ierr = nf90_close(ncid)
    call error_handler(ierr, "WRITE_RESTART:  nf90_close")

  end subroutine hrldas_restart_prepare_seq

#ifdef MPP_LAND
  subroutine hrldas_restart_add_real2d_mpp(array, name, units, description)
    implicit none
    real,            dimension(:,:),                              intent(in) :: array
    real,            dimension(global_nx,global_ny) :: garray
    character(len=*),                                             intent(in) :: name
    character(len=*), optional,                                   intent(in) :: units
    character(len=*), optional,                                   intent(in) :: description
    call write_io_real(array,garray)
    if(my_id .eq. IO_id) then
       call hrldas_restart_add_real2d(garray, name, units, description)
    endif
    call mpp_land_sync()
  end subroutine hrldas_restart_add_real2d_mpp


  subroutine hrldas_restart_add_integer2d_mpp(array, name, units, description)
    implicit none
    integer,            dimension(:,:),                              intent(in) :: array
    integer,            dimension(global_nx,global_ny) :: garray
    character(len=*),                                             intent(in) :: name
    character(len=*), optional,                                   intent(in) :: units
    character(len=*), optional,                                   intent(in) :: description
    call write_io_int(array,garray)
    if(my_id .eq. IO_id) then
       call hrldas_restart_add_integer2d(garray, name, units, description)
    endif
    call mpp_land_sync()
  end subroutine hrldas_restart_add_integer2d_mpp

  subroutine hrldas_restart_add_3d_mpp(array, name, units, description, layers)
    implicit none
    real,            dimension(:,:,:),                            intent(in) :: array
    character(len=*),                                             intent(in) :: name
    character(len=*), optional,                                   intent(in) :: units
    character(len=*), optional,                                   intent(in) :: description
    character(len=4), optional,                                   intent(in) :: layers
    integer  :: k, klevel

    real, allocatable, dimension(:,:,:) :: garray
    klevel = size(array,2)
    allocate(garray(global_nx,klevel,global_ny))

    call write_io_real3d(array,garray,klevel)

    if(my_id .eq. IO_id) then
       call hrldas_restart_add_3d(garray, name, units, description, layers)
    endif
    deallocate(garray)

    call mpp_land_sync()
  end subroutine hrldas_restart_add_3d_mpp
#endif

  subroutine hrldas_restart_add_real2d(array, name, units, description)
    implicit none
    real,            dimension(:,:),                              intent(in) :: array
    character(len=*),                                             intent(in) :: name
    character(len=*), optional,                                   intent(in) :: units
    character(len=*), optional,                                   intent(in) :: description

    character(len=256) :: output_flnm
    integer :: ncid
    integer :: ierr
    integer :: dimid_ix
    integer :: dimid_jx
    integer :: dimid_times
    integer :: ixout
    integer :: xstartout
    integer :: iswater
    character(len=256) :: local_units
    character(len=256) :: local_description

    integer :: ixpar
    integer :: jxpar

    output_flnm = restart_filename_remember
    iswater     = iswater_remember

    ixpar = size(array,1)
    jxpar = size(array,2)

    if (present(units)) then
       local_units = units
    else
       local_units = "-"
    endif

    if (present(description)) then
       local_description = description
    else
       local_description = "-"
    endif

#ifdef _PARALLEL_
    ierr = nf90_open_par(trim(output_flnm), NF90_WRITE, MPI_COMM_WORLD, MPI_INFO_NULL, ncid)
#else
    ierr = nf90_open(trim(output_flnm), NF90_WRITE, ncid)
#endif
    call error_handler(ierr, "hrldas_restart_add:  nf90_open")

    ierr = nf90_inq_dimid(ncid, "west_east", dimid_ix)
    call error_handler(ierr, "hrldas_restart_add:  nf90_inq_dimid for 'west_east'")

    ierr = nf90_inq_dimid(ncid, "south_north", dimid_jx)
    call error_handler(ierr, "hrldas_restart_add:  nf90_inq_dimid for 'south_north'")

    ierr = nf90_inq_dimid(ncid, "Time", dimid_times)
    call error_handler(ierr, "hrldas_restart_add:  nf90_inq_dimid for 'Time'")

    ierr = nf90_redef(ncid)
    call error_handler(ierr, "hrldas_restart_add:  nf90_redef")

    call make_var_att_2d(ncid, dimid_ix, dimid_jx, dimid_times, NF90_FLOAT, name, trim(local_description), trim(local_units))

    ierr = nf90_enddef(ncid)
    call error_handler(ierr, "hrldas_restart_add:  nf90_enddef")

    call put_var_2d(ncid, 1, vegtyp_remember, iswater, ixpar, jxpar, xstartpar_remember, name, array, .true.)

    ierr = nf90_close(ncid)
    call error_handler(ierr, "hrldas_restart_add:  nf90_close")

  end subroutine hrldas_restart_add_real2d


  subroutine hrldas_restart_add_integer2d(array, name, units, description)
    implicit none
    integer,         dimension(:,:),                              intent(in) :: array
    character(len=*),                                             intent(in) :: name
    character(len=*), optional,                                   intent(in) :: units
    character(len=*), optional,                                   intent(in) :: description

    character(len=256) :: output_flnm
    integer :: ncid
    integer :: ierr
    integer :: dimid_ix
    integer :: dimid_jx
    integer :: dimid_times
    integer :: ixout
    integer :: xstartout
    integer :: iswater
    character(len=256) :: local_units
    character(len=256) :: local_description

    integer :: ixpar
    integer :: jxpar

    output_flnm = restart_filename_remember
    iswater     = iswater_remember

    ixpar = size(array,1)
    jxpar = size(array,2)

    if (present(units)) then
       local_units = units
    else
       local_units = "-"
    endif

    if (present(description)) then
       local_description = description
    else
       local_description = "-"
    endif

#ifdef _PARALLEL_
    ierr = nf90_open_par(trim(output_flnm), NF90_WRITE, MPI_COMM_WORLD, MPI_INFO_NULL, ncid)
#else
    ierr = nf90_open(trim(output_flnm), NF90_WRITE, ncid)
#endif
    call error_handler(ierr, "hrldas_restart_add:  nf90_open")

    ierr = nf90_inq_dimid(ncid, "west_east", dimid_ix)
    call error_handler(ierr, "hrldas_restart_add:  nf90_inq_dimid for 'west_east'")

    ierr = nf90_inq_dimid(ncid, "south_north", dimid_jx)
    call error_handler(ierr, "hrldas_restart_add:  nf90_inq_dimid for 'south_north'")

    ierr = nf90_inq_dimid(ncid, "Time", dimid_times)
    call error_handler(ierr, "hrldas_restart_add:  nf90_inq_dimid for 'Time'")

    ierr = nf90_redef(ncid)
    call error_handler(ierr, "hrldas_restart_add:  nf90_redef")

    call make_var_att_2d(ncid, dimid_ix, dimid_jx, dimid_times, NF90_INT, name, trim(local_description), trim(local_units))

    ierr = nf90_enddef(ncid)
    call error_handler(ierr, "hrldas_restart_add:  nf90_enddef")

    call put_var_int(ncid, 1, vegtyp_remember, iswater, ixpar, jxpar, xstartpar_remember, name, array)

    ierr = nf90_close(ncid)
    call error_handler(ierr, "hrldas_restart_add:  nf90_close")

  end subroutine hrldas_restart_add_integer2d


  subroutine hrldas_restart_add_3d(array, name, units, description, layers)
    implicit none
    real,            dimension(:,:,:),                            intent(in) :: array
    character(len=*),                                             intent(in) :: name
    character(len=*), optional,                                   intent(in) :: units
    character(len=*), optional,                                   intent(in) :: description
    character(len=4), optional,                                   intent(in) :: layers

    character(len=256) :: output_flnm
    integer :: ncid
    integer :: ierr
    integer :: dimid_ix
    integer :: dimid_jx
    integer :: dimid_kx
    integer :: dimid_times
    integer :: ixout
    integer :: xstartout
    integer :: iswater
    character(len=256) :: local_units
    character(len=256) :: local_description

    integer :: ixpar
    integer :: jxpar
    integer :: kxpar
    character(len=4) :: output_layers

    output_flnm = restart_filename_remember
    iswater     = iswater_remember

    if (present(layers)) then
       output_layers = layers
    else
       output_layers = "SOIL"
    endif

    ixpar = size(array,1)
    kxpar = size(array,2)
    jxpar = size(array,3)

    if (present(units)) then
       local_units = units
    else
       local_units = "-"
    endif

    if (present(description)) then
       local_description = description
    else
       local_description = "-"
    endif

#ifdef _PARALLEL_
    ierr = nf90_open_par(trim(output_flnm), NF90_WRITE, MPI_COMM_WORLD, MPI_INFO_NULL, ncid)
#else
    ierr = nf90_open(trim(output_flnm), NF90_WRITE, ncid)
#endif
    call error_handler(ierr, "hrldas_restart_add:  nf90_open")

    ierr = nf90_inq_dimid(ncid, "west_east", dimid_ix)
    call error_handler(ierr, "hrldas_restart_add:  nf90_inq_dimid for 'west_east'")

    ierr = nf90_inq_dimid(ncid, "south_north", dimid_jx)
    call error_handler(ierr, "hrldas_restart_add:  nf90_inq_dimid for 'south_north'")

    if (output_layers == "SOIL") then
       ierr = nf90_inq_dimid(ncid, "soil_layers_stag", dimid_kx)
       call error_handler(ierr, "hrldas_restart_add:  nf90_inq_dimid for 'soil_layers_stag'")
    else if (output_layers == "SNOW") then
       ierr = nf90_inq_dimid(ncid, "snow_layers", dimid_kx)
       call error_handler(ierr, "hrldas_restart_add:  nf90_inq_dimid for 'snow_layers'")
    else if (output_layers == "SOSN") then
       ierr = nf90_inq_dimid(ncid, "sosn_layers", dimid_kx)
       call error_handler(ierr, "hrldas_restart_add:  nf90_inq_dimid for 'sosn_layers'")
    else
       stop "PANIC!"
    endif

    ierr = nf90_inq_dimid(ncid, "Time", dimid_times)
    call error_handler(ierr, "hrldas_restart_add:  nf90_inq_dimid for 'Time'")

    ierr = nf90_redef(ncid)
    call error_handler(ierr, "hrldas_restart_add:  nf90_redef")

    call make_var_att_3d(ncid, dimid_ix, dimid_jx, dimid_times, NF90_FLOAT, dimid_kx, name, trim(local_description), trim(local_units))

    ierr = nf90_enddef(ncid)
    call error_handler(ierr, "hrldas_restart_add:  nf90_enddef")

    call put_var_3d(ncid, 1, vegtyp_remember, iswater, ixpar, jxpar, xstartpar_remember, kxpar, name, array)

    ierr = nf90_close(ncid)
    call error_handler(ierr, "hrldas_restart_add:  nf90_close")

  end subroutine hrldas_restart_add_3d


  subroutine hrldas_restart_read(filename, &
       xstart, xend, ystart, yend, nsoil, &
       olddate)
    ! The restart file is dimensioned by our (possibly subwindowed) grid.  Our indices
    ! for the parallel I/O reflect the dimensions of the (possibly subwindowed) grid,
    ! but not the full domain for which LDAS input files may be available.
    implicit none
    character(len=*), intent(in) :: filename
    integer, intent(in) :: xstart
    integer, intent(in) :: xend
    integer, intent(in) :: ystart
    integer, intent(in) :: yend
    integer, intent(in) :: nsoil
    character(len=19), intent(out) :: olddate

    integer :: ierr
    integer :: ncid
    integer :: varid
    character(len=256) :: titlestr
    integer :: restart_version
    integer :: idx
    integer, dimension(4) :: nstart
    integer, dimension(4) :: ncount
    integer :: rank
    integer :: read_sfcdif

#ifdef MPP_LAND
    if(my_id /= io_id) return
#endif

    restart_filename_remember = filename

    ierr = nf90_open(trim(filename), NF90_NOWRITE, ncid)
    call error_handler(ierr, failure='ERROR[HRLDAS_RESTART_READ]: Failed to open the file' // trim(filename))

    ierr = nf90_get_att(ncid, NF90_GLOBAL, "TITLE", titlestr)
    if (ierr /= 0) then
       write(*,*) 'WARNING[HRLDAS_RESTART_READ]: RESTART file does not have TITLE attribute.'
       restart_version = 0
    else
       write(*,*) 'INFO[HRLDAS_RESTART_READ]: RESTART TITLE attribute: ' // trim(titlestr)
       idx = index(trim(titlestr), "v20")
       if (idx <= 0) then
          write(*,*) 'ERROR[HRLDAS_RESTART_READ]: RESTART file has a perverse version identifier'
          stop
       else
          read(titlestr(idx+1:), '(I8)', iostat=ierr) restart_version
          if (ierr /= 0) then
             write(*,*)'ERROR[HRLDAS_RESTART_READ]: RESTART file has a perverse version identifier'
             stop
          endif
       endif
       write(*,*) 'INFO[HRLDAS_RESTART_READ]: RESTART file version: ', restart_version
    endif

    ! Get the time stamp from the restart file.
    ierr = nf90_inq_varid(ncid, "Times", varid)
    call error_handler(ierr, "ERROR[HRLDAS_RESTART_READ]: Problems finding the 'Times' variable in restart file")

    ierr = nf90_get_var(ncid, varid, olddate)
    call error_handler(ierr, "ERROR[HRLDAS_RESTART_READ]: Problems reading the 'Times' variable from restart file")

    ierr = nf90_close(ncid)
    call error_handler(ierr, "ERROR[HRLDAS_RESTART_READ]: Problems closing restart file" // trim(filename))

  end subroutine hrldas_restart_read


#ifdef MPP_LAND
  subroutine hrldas_restart_get_real2d_mpp(xstart, xend, ystart, yend, name, array, return_error)
    implicit none
    integer, intent(in) :: xstart
    integer, intent(in) :: xend
    integer, intent(in) :: ystart
    integer, intent(in) :: yend
    character(len=*), intent(in) :: name
    real, dimension(xstart:xend,ystart:yend), intent(out) :: array
    integer, optional, intent(out) :: return_error

    real, dimension(global_nx,global_ny):: garray

    if(my_id == io_id) then
       call hrldas_restart_get_real2d(1, global_nx, 1, global_ny, name, garray, return_error)
    endif
    call decompose_data_real(garray,array)
  end subroutine hrldas_restart_get_real2d_mpp


  subroutine hrldas_restart_get_integer2d_mpp(xstart, xend, ystart, yend, name, array, return_error)
    implicit none
    integer, intent(in) :: xstart
    integer, intent(in) :: xend
    integer, intent(in) :: ystart
    integer, intent(in) :: yend
    character(len=*), intent(in) :: name
    integer, dimension(xstart:xend,ystart:yend), intent(out) :: array
    integer, optional, intent(out) :: return_error

    integer, dimension(global_nx,global_ny):: garray

    if(my_id == io_id) then
       call hrldas_restart_get_integer2d(1, global_nx, 1, global_ny, name, garray, return_error)
    endif
    call decompose_data_int(garray, array)
  end subroutine hrldas_restart_get_integer2d_mpp


  subroutine hrldas_restart_get_3d_mpp(xstart, xend, ystart, yend, name, array, return_error)
    implicit none
    integer, intent(in) :: xstart
    integer, intent(in) :: xend
    integer, intent(in) :: ystart
    integer, intent(in) :: yend
    character(len=*), intent(in) :: name
    real, dimension(:,:,:), intent(out) :: array
    integer, optional, intent(out) :: return_error

    integer :: klevel,k
    real, allocatable, dimension(:,:,:) :: garray

    klevel = size(array,2)
    allocate(garray(global_nx,klevel,global_ny))

    if(my_id == io_id) then
       call hrldas_restart_get_3d(1, global_nx, 1, global_ny, name, garray, return_error)
    endif
    do k = 1, klevel
       call decompose_data_real(garray(:,k,:),array(:,k,:))
    end do
    deallocate(garray)
  end subroutine hrldas_restart_get_3d_mpp
#endif


  subroutine hrldas_restart_get_att(itime)
    implicit none
    integer,intent(out) :: itime
    integer  :: ncid, ierr
#ifdef MPP_LAND
    if (my_id /= io_id) return
#endif
    ierr = nf90_open(trim(restart_filename_remember), NF90_NOWRITE, ncid)
    ierr = nf90_get_att(ncid, NF90_GLOBAL, "ITIMESTEP", itime)
    call error_handler(ierr, failure="ERROR[HRLDAS_RESTART_GET]: Problems finding global attribute 'ITIMESTEP'")
    ierr = nf90_close(ncid)
  end subroutine hrldas_restart_get_att


  subroutine hrldas_restart_get_real2d(xstart, xend, ystart, yend, name, array, return_error)
    implicit none
    integer, intent(in) :: xstart
    integer, intent(in) :: xend
    integer, intent(in) :: ystart
    integer, intent(in) :: yend
    character(len=*), intent(in) :: name
    real, dimension(xstart:xend,ystart:yend), intent(out) :: array
    integer, optional, intent(out) :: return_error

    integer :: ierr
    integer :: ncid
    integer :: varid
    integer, dimension(4) :: nstart
    integer, dimension(4) :: ncount
    integer :: rank

#ifdef MPP_LAND
    if (my_id /= io_id) then
       if (present(return_error)) return_error = 1
       return
    endif
#endif

    ierr = nf90_open(trim(restart_filename_remember), NF90_NOWRITE, ncid)
    call error_handler(ierr, "ERROR[HRLDAS_RESTART_GET]: Problem opening restart file "//trim(restart_filename_remember))

    nstart = (/ xstart, ystart, 1, -99999 /)
    ncount = (/ xend-xstart+1, yend-ystart+1, 1, -99999 /)

    ierr = nf90_inq_varid(ncid, trim(name), varid)
    if (ierr == NF90_NOERR) then
       if (present(return_error)) then
          return_error = 0
       endif
    else
       if (present(return_error)) then
          return_error = 1
       endif
       call error_handler(ierr, 'ERROR[HRLDAS_RESTART_GET]: Problems finding '//trim(name)//' in file '//trim(restart_filename_remember))
    endif

    ierr = nf90_get_var(ncid, varid, array, start=nstart(1:3), count=ncount(1:3))
    if (ierr == NF90_NOERR) then
       if (present(return_error)) then
          return_error = 0
       endif
    else
       if (present(return_error)) then
          return_error = 1
       endif
       call error_handler(ierr, 'ERROR[HRLDAS_RESTART_GET]: Problems reading '//trim(name)//' from file '//trim(restart_filename_remember))
    endif

    ierr = nf90_close(ncid)
    if (ierr == NF90_NOERR) then
       if (present(return_error)) then
          return_error = 0
       endif
    else
       if (present(return_error)) then
          return_error = 1
       endif
       call error_handler(ierr, 'ERROR[HRLDAS_RESTART_GET]: Problems closing file '//trim(restart_filename_remember))
    endif
  end subroutine hrldas_restart_get_real2d


  subroutine hrldas_restart_get_integer2d(xstart, xend, ystart, yend, name, array, return_error)
    implicit none
    integer, intent(in) :: xstart
    integer, intent(in) :: xend
    integer, intent(in) :: ystart
    integer, intent(in) :: yend
    character(len=*), intent(in) :: name
    integer, dimension(xstart:xend,ystart:yend), intent(out) :: array
    integer, optional, intent(out) :: return_error

    integer :: ierr
    integer :: ncid
    integer :: varid
    integer, dimension(4) :: nstart
    integer, dimension(4) :: ncount

#ifdef MPP_LAND
    if (my_id /= io_id) then
       if (present(return_error)) return_error = 1
       return
    endif
#endif

    ierr = nf90_open(trim(restart_filename_remember), NF90_NOWRITE, ncid)
    call error_handler(ierr, "ERROR[HRLDAS_RESTART_GET]: Problem opening restart file "//trim(restart_filename_remember))

    nstart = (/ xstart, ystart, 1, -99999 /)
    ncount = (/ xend-xstart+1, yend-ystart+1, 1, -99999 /)

    ierr = nf90_inq_varid(ncid, trim(name), varid)
    if (ierr == NF90_NOERR) then
       if (present(return_error)) then
          return_error = 0
       endif
    else
       if (present(return_error)) then
          return_error = 1
       endif
       call error_handler(ierr, 'ERROR[HRLDAS_RESTART_GET]: Problems finding '//trim(name)//' in file '//trim(restart_filename_remember))
    endif

    ierr = nf90_get_var(ncid, varid, array, start=nstart(1:3), count=ncount(1:3))
    if (ierr == NF90_NOERR) then
       if (present(return_error)) then
          return_error = 0
       endif
    else
       if (present(return_error)) then
          return_error = 1
       endif
       call error_handler(ierr, 'ERROR[HRLDAS_RESTART_GET]: Problems reading '//trim(name)//' from file '//trim(restart_filename_remember))
    endif

    ierr = nf90_close(ncid)
    if (ierr == NF90_NOERR) then
       if (present(return_error)) then
          return_error = 0
       endif
    else
       if (present(return_error)) then
          return_error = 1
       endif
       call error_handler(ierr, 'ERROR[HRLDAS_RESTART_GET]: Problems closing file '//trim(restart_filename_remember))
    endif
  end subroutine hrldas_restart_get_integer2d


  subroutine hrldas_restart_get_3d(xstart, xend, ystart, yend, name, array, return_error)
    implicit none
    integer, intent(in) :: xstart
    integer, intent(in) :: xend
    integer, intent(in) :: ystart
    integer, intent(in) :: yend
    character(len=*), intent(in) :: name
    real, dimension(:,:,:), intent(out) :: array
    integer, optional, intent(out) :: return_error

    integer :: ierr
    integer :: ncid
    integer :: varid
    integer, dimension(4) :: nstart
    integer, dimension(4) :: ncount

#ifdef MPP_LAND
    if (my_id /= io_id) then
       if (present(return_error)) return_error = 1
       return
    endif
#endif

    ierr = nf90_open(trim(restart_filename_remember), NF90_NOWRITE, ncid)
    call error_handler(ierr, "ERROR[HRLDAS_RESTART_GET]: Problem opening restart file "//trim(restart_filename_remember))

    nstart = (/ xstart, 1, ystart, 1 /)
    ncount = (/ xend-xstart+1, size(array,2), yend-ystart+1, 1 /)

    ierr = nf90_inq_varid(ncid, trim(name), varid)
    if (ierr == NF90_NOERR) then
       if (present(return_error)) then
          return_error = 0
       endif
    else
       if (present(return_error)) then
          return_error = 1
       endif
       call error_handler(ierr, 'ERROR[HRLDAS_RESTART_GET]: Problems finding '//trim(name)//' in file '//trim(restart_filename_remember))
    endif

    ierr = nf90_get_var(ncid, varid, array, start=nstart(1:4), count=ncount(1:4))
    if (ierr == NF90_NOERR) then
       if (present(return_error)) then
          return_error = 0
       endif
    else
       if (present(return_error)) then
          return_error = 1
       endif
       call error_handler(ierr, 'ERROR[HRLDAS_RESTART_GET]: Problems reading '//trim(name)//' from file '//trim(restart_filename_remember))
    endif

    ierr = nf90_close(ncid)
    if (ierr == NF90_NOERR) then
       if (present(return_error)) then
          return_error = 0
       endif
    else
       if (present(return_error)) then
          return_error = 1
       endif
       call error_handler(ierr, 'ERROR[HRLDAS_RESTART_GET]: Problems closing file '//trim(restart_filename_remember))
    endif
  end subroutine hrldas_restart_get_3d


  subroutine error_handler(status, failure, success)
    ! Check the error flag from a NetCDF function call, and print appropriate
    ! error message.
    implicit none
    integer, intent(in) :: status
    character(len=*), optional, intent(in) :: failure
    character(len=*), optional, intent(in) :: success

    if (status .ne. NF90_NOERR) then
       write(*,'(A)') nf90_strerror(status)
       if (present(failure)) then
          write(*,'(A)') failure
       endif
       stop 'Stopped'
    endif

    if (present(success)) then
       write(*,'(A)') success
    endif

  end subroutine error_handler


  subroutine read_additional(flnm_template, hdate, name, xstart, xend, ystart, yend, array, ierr)
    use kwm_string_utilities
    implicit none
    character(len=*),                         intent(in)  :: flnm_template
    character(len=*),                         intent(in)  :: hdate
    character(len=*),                         intent(in)  :: name
    integer,                                  intent(in)  :: xstart
    integer,                                  intent(in)  :: xend
    integer,                                  intent(in)  :: ystart
    integer,                                  intent(in)  :: yend
    real, dimension(xstart:xend,ystart:yend), intent(out) :: array
    integer,                                  intent(out) :: ierr

    character(len=256) :: flnm
    integer :: jday
    character(len=3) :: hjday
    integer :: ncid
    integer :: varid
    logical :: lexist

    call geth_idts(hdate(1:10), hdate(1:4)//"-01-01", jday)
    jday = jday + 1
    write(hjday,'(I3.3)') jday

    flnm = flnm_template

    call strrep(flnm, "<YYYY>", hdate(1:4))
    call strrep(flnm, "<MM>", hdate(6:7))
    call strrep(flnm, "<DD>", hdate(9:10))
    call strrep(flnm, "<HH>", hdate(12:13))
    call strrep(flnm, "<JDAY>", hjday)

    inquire(file=trim(flnm), exist=lexist)
    if (.not. lexist) then
       ierr = 1
       return
    endif

    write(*, '("Additional flnm = ''",A,"''")') trim(flnm)

#ifdef _PARALLEL_
    ierr = nf90_open_par(trim(flnm), NF90_NOWRITE, MPI_COMM_WORLD, MPI_INFO_NULL, ncid)
#else
    ierr = nf90_open(trim(flnm), NF90_NOWRITE, ncid)
#endif
    call error_handler(ierr, failure="READ_ADDITIONAL: Problem opening additional file: "//trim(flnm))

    ierr = nf90_inq_varid(ncid,  name,  varid)
    call error_handler(ierr, failure="READ_ADDITIONAL: Problem finding variable: "//name)

    ierr = nf90_get_var(ncid, varid, array, start=(/xstart,ystart/), count=(/xend-xstart+1,yend-ystart+1/))
    call error_handler(ierr, failure="READ_ADDITIONAL: Problem getting variable: "//name)

    ierr = nf90_close(ncid)
    call error_handler(ierr, failure="READ_ADDITIONAL:  Problem closing file:  "//trim(flnm))

  end subroutine read_additional

end module module_hrldas_netcdf_io
